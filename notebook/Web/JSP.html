
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						<link rel="stylesheet" href="pluginAssets/katex/katex.css"><script type="application/javascript" src="pluginAssets/mermaid/mermaid.min.js"></script><script type="application/javascript" src="pluginAssets/mermaid/mermaid_render.js"></script><link rel="stylesheet" href="pluginAssets/highlight.js/atom-one-light.css">
						<title>JSP</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">JSP</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		strong {
			color: #000000;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}
		::-webkit-scrollbar {
			width: 7px;
			height: 7px;
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(100, 100, 100, 0.3); 
			border-radius: 5px;
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(100, 100, 100, 0.7); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to precvent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		.not-loaded-resource img {
			width: 1.15em;
			height: 1.15em;
			background: white;
			padding: 2px !important;
			border-radius: 2px;
			box-shadow: 0 1px 3px #000000aa;
		}

		a.not-loaded-resource img {
			margin-right: .2em;
		}

		a.not-loaded-resource {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 100vh;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { background-color: white; width: 640px; }
@font-face {
    font-family: 'PT Serif';
    font-style: normal;
    font-weight: normal;
    src: local('PT Serif'), local('PTSerif-Regular'), url('./newsprint/pt-serif-v9-latin-regular.woff') format('woff');
}
@font-face {
    font-family: 'PT Serif';
    font-style: italic;
    font-weight: normal;
    src: local('PT Serif'), local('PTSerif-Italic'), url('./newsprint/pt-serif-v9-latin-italic.woff') format('woff');
}

@font-face {
    font-family: 'PT Serif';
    font-style: normal;
    font-weight: bold;
    src: local('PT Serif'), local('PTSerif-Bold'), url('./newsprint/pt-serif-v9-latin-700.woff') format('woff');
}

@font-face {
    font-family: 'PT Serif';
    font-style: italic;
    font-weight: bold;
    src: local('PT Serif'), local('PTSerif-BoldItalic'), url('./newsprint/pt-serif-v9-latin-700italic.woff') format('woff');
}


html {
    font-size: 16px;
    color: #1f0909;
}

body {
    font-family: "PT Serif", 'Times New Roman', Times, serif;
    color: #34495e;
    /*-webkit-font-smoothing: antialiased;*/
    line-height: 1.6rem;
    /*font-size: 0.5rem*/
    letter-spacing: 0;
    margin: 0;
    overflow-x: hidden;
    color: #1f0909;
}

p{
    font-size: 1.0rem
}
ol,ul{
    font-size: 1.0rem
}

body > *:first-child {
    margin-top: 0 !important;
}

body > *:last-child {
    margin-bottom: 0 !important;
}


a {
    color: #999966;
    font-weight: 600;
    padding: 0 2px;
    text-decoration: none;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}

h1 tt,
h1 code {
    font-size: inherit !important;
}

h2 tt,
h2 code {
    font-size: inherit !important;
}

h3 tt,
h3 code {
    font-size: inherit !important;
}

h4 tt,
h4 code {
    font-size: inherit !important;
}

h5 tt,
h5 code {
    font-size: inherit !important;
}

h6 tt,
h6 code {
    font-size: inherit !important;
}

/*下面是标题链接的颜色*/
h1 a,
h2 a,
h3 a,
h4 a,
h5 a,
h6 a{
    /*color: #42b983;*/
    color: #666666;
}

h1 {
    padding-bottom: .4rem;
    font-size: 1.8rem;
    line-height: 1.3;
    font-style: normal;
    border-bottom: none;
}

h2 {
    font-size: 1.6rem;
    line-height: 1.225;
    margin: 35px 0 15px;
    padding-bottom: 0.5em;
    border-bottom: 1px solid #ddd;
    font-style: normal;
}

h3 {
    font-size: 1.4rem;
    /*line-height: 1.43;*/
    margin: 20px 0 7px;
    font-style: normal;
}

h4 {
    font-size: 1.3rem;
    font-style: normal;
}

h5 {
    font-size: 1.2rem;
    font-style: normal;
}

h6 {
    font-size: 1.1rem;
    /*color: #777;*/
    font-style: normal;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8em 0;
}

li > ol,
li > ul {
    margin: 0 0;
}

p pre {
    border: none;
}

hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}

body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}

body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}

a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}

h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,
ol {
    padding-left: 30px;
}

ul:first-child,
ol:first-child {
    margin-top: 0;
}

ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

blockquote {
    border-left: 4px solid #42b983;
    /*padding: 10px 10px;*/
    color: #2B3F52;
    background-color: #F7F9FA;
    border-left-color: #ECF0F3;
}

table {
    padding: 0;
    word-break: initial;
    font-size: 1.0rem
}

table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}

table tr:nth-child(2n),
thead {
    background-color: #fafafa;
}

table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
    font-size: 1.0rem
}

table tr td {
    border: 1px solid #dfe2e5;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
    font-size: 0.8rem
}

table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}

table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

p code{
    border: none !important;
    color: #ff6666;
    background-color: #f8f8f8 !important;
    /*border: none;*/
}

strong {

    color:#FF9933;

    size: 100px;

    margin: 0em;

    font-size: inherit;

    /*font-style: italic;*/

}

@media print {
    html {
        font-size: 13px;
    }

    table,
    pre {
        page-break-inside: avoid;
    }

    pre {
        word-wrap: break-word;
    }
    h1,h2,h3,h4,h5,h6 {
    	color: #336699;
    	page-break-inside: avoid;
    	page-break-after: avoid;
    }
    img { 
     page-break-inside:avoid;
     page-break-after:avoid;
 	}
 	table,pre { page-break-inside:avoid}
    ul,ol,dl{ page-break-before:avoid}
    a{page-break-inside:avoid}
    blockquote {page-break-inside: avoid;}
}

/*blockquote{
	border-left-color: #ECF0F3;
}*/

nav.table-of-contents ul {
    list-style-type: none;
    margin-top: 0px;
    margin-bottom: 0px;
}

nav.table-of-contents>ul {

    top: 5px;
    right: 0px;
    z-index: 99;
    
    font-size: 12px;
    position: fixed;
    padding: 15px;
    
    border-radius: 10px 0px 0px 10px;
    margin: 0px;
    
    overflow: hidden;
    height: 90%;
    width: 5px;
    transition: .2s;
}
nav.table-of-contents::after {
    content: "[目录 - 请将你的鼠标移至程序的右边]";
    color: black;
}

nav.table-of-contents>ul:hover {
    background: #F8F8F8;
    box-shadow: -5px 0px 10px 0px rgba(0,0,0,0.15);

    width: 30%;
    color: none;
    overflow: scroll;
}

nav.table-of-contents>ul:hover::before {
    content: "目录"
}

nav.table-of-contents>ul:hover li {
    display: list-item;
}

nav.table-of-contents li {
    display: none;
    white-space: nowrap;
    overflow: hidden;
    margin: 0px;
    padding: 0px;
}


    #rendered-md {
    width: 100%;
    }
}
</style><div id="rendered-md"><nav class="table-of-contents"><ul><li><a href="#jsp">JSP</a><ul><li><a href="#什么是jsp">什么是JSP</a></li><li><a href="#jsp的本质是什么">JSP的本质是什么</a></li><li><a href="#jsp的指令元素及脚本元素">JSP的指令元素及脚本元素</a></li><li><a href="#jsp的九大内置对象">JSP的九大内置对象</a></li><li><a href="#jsp四大域对象">JSP四大域对象</a></li><li><a href="#jsp的out输出流对象和responsegetwriter输出流的区别">JSP的out输出流对象和response.getWriter()输出流的区别</a></li><li><a href="#jsp里的常用标签">JSP里的常用标签</a></li><li><a href="#什么是listener监听器">什么是Listener监听器？</a></li><li><a href="#servletcontextlistener监听器">ServletContextListener监听器</a></li><li><a href="#el表达式">EL表达式</a><ul><li><a href="#empty运算">empty运算</a></li><li><a href="#点运算和中括号运算符">&quot;.&quot;点运算和[]中括号运算符</a></li><li><a href="#el表达式的11个隐含对象">EL表达式的11个隐含对象</a></li><li><a href="#el获取四个特定域中的属性">EL获取四个特定域中的属性</a></li><li><a href="#el-pagecontext对象的使用">EL pageContext对象的使用</a></li><li><a href="#el-表达式其他隐含对象的使用">EL 表达式其他隐含对象的使用</a></li></ul></li><li><a href="#jstl表达式和文件上传和下载详见尚硅谷笔记">JSTL表达式和文件上传和下载详见尚硅谷笔记</a></li><li><a href="#利用反射使请求可以映射到对应servlet里的对应方法">利用反射使请求可以映射到对应Servlet里的对应方法</a></li><li><a href="#cookie">Cookie</a><ul><li><a href="#什么是cookie">什么是Cookie？</a></li><li><a href="#cookie到底是怎么回事">Cookie到底是怎么回事？</a></li><li><a href="#服务器端如何创建cookie给客户端">服务器端如何创建Cookie给客户端？</a></li><li><a href="#服务器端如何修改客户端的cookie">服务器端如何修改客户端的Cookie？</a></li><li><a href="#服务器如何获取客户端每次请求发送过来的cookie">服务器如何获取客户端每次请求发送过来的Cookie？</a></li><li><a href="#cookie的生命周期">Cookie的生命周期</a></li><li><a href="#cookie有效路径path的设置">Cookie有效路径Path的设置</a></li><li><a href="#cookie实现免用户名登录">Cookie实现免用户名登录</a></li></ul></li><li><a href="#session">Session</a><ul><li><a href="#什么是session">什么是Session？</a></li><li><a href="#session的作用">Session的作用?</a></li><li><a href="#如何创建和获取sessionid号是否为新">如何创建和获取Session？(id号，是否为新)</a></li><li><a href="#session域中的存取">Session域中的存取</a></li><li><a href="#session-生命周期控制">Session 生命周期控制</a></li><li><a href="#浏览器和session之间关联的技术内幕">浏览器和Session之间关联的技术内幕</a></li><li><a href="#为什么说每次打开浏览器会创建一个session每次关闭浏览器session就没有了">为什么说每次打开浏览器会创建一个Session，每次关闭浏览器Session就没有了？</a></li></ul></li><li><a href="#用户登录">用户登录</a><ul><li><a href="#显示登录的用户信息">显示登录的用户信息</a></li><li><a href="#登出-注销用户">登出---注销用户</a></li></ul></li><li><a href="#表单重复提交及解决方案">表单重复提交及解决方案</a><ul><li><a href="#表单重复提交有三种常见的情况">表单重复提交有三种常见的情况：</a></li><li><a href="#验证码解决表单重复提交">验证码解决表单重复提交</a></li><li><a href="#谷歌kaptcha图片验证码的使用">谷歌kaptcha图片验证码的使用</a></li></ul></li><li><a href="#购物车的实现">购物车的实现</a><ul><li><a href="#市面上购物车的实现技术版本有">市面上购物车的实现技术版本有：</a><ul><li><a href="#session版本把购物车信息保存到session域中">Session版本(把购物车信息保存到Session域中)</a></li><li><a href="#数据库版本把购物车信息保存到数据库">数据库版本(把购物车信息，保存到数据库)</a></li><li><a href="#redis数据库cookie使用cookieredis缓存和数据库">redis+数据库+Cookie(使用Cookie+Redis缓存，和数据库)</a></li></ul></li></ul></li><li><a href="#filter">Filter</a><ul><li><a href="#filter-什么是过滤器">Filter 什么是过滤器？</a></li><li><a href="#filter-的作用">Filter 的作用</a></li><li><a href="#filter初体验权限检查">Filter初体验：权限检查</a></li><li><a href="#过滤器的大致原理">过滤器的大致原理</a></li><li><a href="#过滤器的代码实现">过滤器的代码实现</a></li><li><a href="#filter过滤器的使用步骤">Filter过滤器的使用步骤:</a></li><li><a href="#filter的生命周期">Filter的生命周期</a></li><li><a href="#filterconfig类">FilterConfig类</a></li><li><a href="#filterchain-过滤器链">FilterChain 过滤器链</a></li><li><a href="#filter的拦截路径">Filter的拦截路径</a></li></ul></li><li><a href="#threadlocal的使用">ThreadLocal的使用</a><ul><li><a href="#回顾jdbc的数据库事务管理">回顾Jdbc的数据库事务管理</a></li><li><a href="#如何确保所有操作都是用同一个connection连接对象">如何确保所有操作都是用同一个Connection连接对象？</a></li></ul></li><li><a href="#使用-filter-和-threadlocal-组合管理事务">使用 Filter 和 ThreadLocal 组合管理事务</a></li><li><a href="#使用filter过滤器统一给所有的service方法都加上try-catch">使用Filter过滤器统一给所有的Service方法都加上try-catch</a></li><li><a href="#json在java中的使用">JSON在Java中的使用</a></li><li><a href="#i18n国际化">i18n国际化</a><ul><li><a href="#什么是i18n国际化">什么是i18n国际化</a></li><li><a href="#国际化三要素">国际化三要素</a></li><li><a href="#国际化基础示例">国际化基础示例</a></li><li><a href="#从请求头中获取locale对象">从请求头中获取Locale对象</a></li></ul></li><li><a href="#ajax请求">AJAX请求</a><ul><li><a href="#什么是ajax请求">什么是AJAX请求</a></li><li><a href="#原生javascipt的ajax请求示例">原生JavaScipt的AJAX请求示例</a></li><li><a href="#怎么理解ajax的局部更新">怎么理解AJAX的局部更新？</a></li><li><a href="#怎么理解ajax的异步请求">怎么理解AJAX的异步请求？</a><ul><li><a href="#什么叫同步">什么叫同步？</a></li><li><a href="#什么叫异步">什么叫异步？</a></li><li><a href="#ajax异步请求">AJAX异步请求</a></li><li><a href="#为什么要有异步请求">为什么要有异步请求？</a></li></ul></li><li><a href="#jquery中的ajax请求">jQuery中的AJAX请求</a><ul><li><a href="#ajax方法">$.ajax方法</a></li></ul></li></ul></li></ul></li></ul></nav><h1 id="jsp">JSP</h1>
<p><a data-from-md title='https://blog.csdn.net/rubulai/article/details/91585770' href='https://blog.csdn.net/rubulai/article/details/91585770'>https://blog.csdn.net/rubulai/article/details/91585770</a></p>
<h3 id="什么是jsp">什么是JSP</h3>
<ul>
<li>jsp是 Java server pages 的缩写，即Java的服务器页面</li>
<li>jsp的主要作用是代替Servelt 回传html页面的程序。</li>
<li>因为Servlet回传html页面数据极其繁琐，writer.write(&quot;html代码&quot;)，开发和维护成本极高。</li>
<li>Servlet 回传 html 页面数据的代码：</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">public class PringHtml extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws 		ServletException,
    IOException {
        // 通过响应的回传流回传 html 页面数据
        resp.setContentType(&quot;text/html; charset=UTF-8&quot;);
        PrintWriter writer = resp.getWriter();
        writer.write(&quot;&lt;!DOCTYPE html&gt;\r\n&quot;);
        writer.write(&quot; &lt;html lang=\&quot;en\&quot;&gt;\r\n&quot;);
        writer.write(&quot; &lt;head&gt;\r\n&quot;);
        writer.write(&quot; &lt;meta charset=\&quot;UTF-8\&quot;&gt;\r\n&quot;);
        writer.write(&quot; &lt;title&gt;Title&lt;/title&gt;\r\n&quot;);
        writer.write(&quot; &lt;/head&gt;\r\n&quot;);
        writer.write(&quot; &lt;body&gt;\r\n&quot;);
        writer.write(&quot; 这是 html 页面数据 \r\n&quot;);
        writer.write(&quot; &lt;/body&gt;\r\n&quot;);
        writer.write(&quot;&lt;/html&gt;\r\n&quot;);
        writer.write(&quot;\r\n&quot;);
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PringHtml</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">HttpServlet</span> {
    <span class="hljs-meta">@Override</span>
    protected void doGet(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> 		<span class="hljs-type">ServletException</span>,
    <span class="hljs-type">IOException</span> {
        <span class="hljs-comment">// 通过响应的回传流回传 html 页面数据</span>
        resp.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);
        <span class="hljs-type">PrintWriter</span> writer <span class="hljs-operator">=</span> resp.getWriter();
        writer.write(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;html lang=<span class="hljs-subst">\&quot;</span>en<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;head&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;meta charset=<span class="hljs-subst">\&quot;</span>UTF-8<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;title&gt;Title&lt;/title&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;/head&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; 这是 html 页面数据 <span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot; &lt;/body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot;&lt;/html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
        writer.write(<span class="hljs-string">&quot;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);
    }
}</code></pre></div>
<ul>
<li>jsp回传一个简单html页面的代码：</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是 html 页面数据
    &lt;/body&gt;
&lt;/html&gt;</pre><pre class="hljs"><code><span class="language-xml">&lt;%</span><span class="language-ruby">@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> </span><span class="language-xml">%&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        这是 html 页面数据
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div>
<hr>
<h3 id="jsp的本质是什么">JSP的本质是什么</h3>
<ul>
<li><strong>jsp页面本质上是一个Servlet程序</strong></li>
<li>当我们第一次访问jsp页面的时候。Tomcat服务器会把jsp页面翻译成一个java源文件。并且对他进行编译为.class字节码程序。如a.jsp,就被翻译为a_jsp.java类，而它继承了HttpJspBase类，而HttpJspBase继承了HttpServlet类。也就是说，翻译出来的是一个Servlet程序。</li>
<li><strong>jsp页面中的html代码也是通过输出流out.wirte()把html页面数据回传给客户端。</strong></li>
</ul>
<hr>
<h3 id="jsp的指令元素及脚本元素">JSP的指令元素及脚本元素</h3>
<ol>
<li>指令语法<br>
<em><strong>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</strong></em><br>
contentType: 表示jspfanhui的数据类型是什么，及指定返回的数据编码格式<br>
pageEncoding: 表示当前jsp页面的编码格式<br>
isErrorPage=&quot;true&quot; 开启后jsp会在_jspService()中提供一个exception对象</li>
<li>脚本元素
<ol>
<li><em><strong>&lt;% %&gt;</strong></em> : java代码
<ul>
<li>代码脚本的作用是: 编写java代码</li>
<li>所有的代码脚本都会被翻译到_jspService()方法中</li>
<li>由于代码脚本翻译的内容都在_jspService()方法中，所以_jspService()方法中的对象都可以直接使用。</li>
</ul>
</li>
<li><em><strong>&lt;%= %&gt;</strong></em> : 表示式值 out.println();
<ul>
<li>表达式脚本的作用是: 在jsp页面上输出数据。</li>
<li>所有的表达式脚本都会被翻译到_jspService()方法中</li>
<li>表达式脚本都会被翻译为out.print()语句输出到页面上</li>
<li>由于表达式脚本翻译的内容都在_jspService()方法中，所以_jspService()方法中的对象都可以直接使用。</li>
</ul>
</li>
<li><em><strong>&lt;%! %&gt;</strong></em> : 设置当前JSP的成员变量(因为jsp本身是个java类文件)</li>
</ol>
</li>
</ol>
<hr>
<h3 id="jsp的九大内置对象">JSP的九大内置对象</h3>
<ul>
<li>jsp的内置对象,是指Tomcat在翻译jsp页面成为Servlet源代码后，内部提供的九大对象叫内置对象。</li>
</ul>
<ol>
<li><em><strong>request</strong></em> 请求对象</li>
<li><em><strong>response</strong></em> 响应对象</li>
<li><em><strong>pageContext</strong></em> jsp的上下文对象</li>
<li><em><strong>session</strong></em> 会话对象</li>
<li><em><strong>application</strong></em> ServletContext对象</li>
<li><em><strong>config</strong></em> ServletConfig对象</li>
<li><em><strong>out</strong></em> jsp输出流对象</li>
<li><em><strong>page</strong></em> 指向当前jsp的对象</li>
<li><em><strong>exception</strong></em> 异常对象</li>
</ol>
<hr>
<h3 id="jsp四大域对象">JSP四大域对象</h3>
<ul>
<li>域对象是可以像Map一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围。</li>
<li><em><strong>pageContext</strong></em> PageContextImpl类			当前jsp页面范围内有效</li>
<li><em><strong>request</strong></em> HttpServletRequest类		一次请求内有效</li>
<li><em><strong>session</strong></em> HttpSession类			一个会话范围内有效(打开浏览器访问服务器，直到关闭浏览器会话结束,只要浏览器没关闭都共享这一个session，不同浏览器不共享session，但共享application)</li>
<li><em><strong>application</strong></em> ServletContext类		整个web工程范围内都有效(只要web工程不停止，数据都在)</li>
</ul>
<h3 id="jsp的out输出流对象和responsegetwriter输出流的区别">JSP的out输出流对象和response.getWriter()输出流的区别</h3>
<ul>
<li>out流就是response.getWriter()得到的</li>
<li>jsp翻译之后，底层源代码都是用out来进行输出，所以在jsp页面中，一般统一使用out.print()方法来输出</li>
<li>out.wirte()是用来输出字符串的</li>
<li>out.print()，如果参数不是字符串，会先转换成String，然后再输出</li>
</ul>
<hr>
<h3 id="jsp里的常用标签">JSP里的常用标签</h3>
<ol>
<li>jsp静态包含<br>
<em><strong>&lt;%@ include file=&quot;/资源名称&quot; %&gt;</strong></em>
<ul>
<li>静态包含不会翻译被包含的jsp页面</li>
<li>静态包含其实是把被包含的jsp页面的代码拷贝到包含的位置执行输出</li>
<li>file属性指定你要包含的jsp页面的路径</li>
<li>&quot;/&quot; 表示为 <a data-from-md title='http://ip' href='http://ip'>http://ip</a>:port/工程路径/ 映射到代码的web目录</li>
</ul>
</li>
<li>jsp动态包含<br>
<em><strong>&lt;jsp:include page=&quot;/footer.jsp&quot; %&gt;&lt;/jsp:include&gt;</strong></em>
<ul>
<li>动态包含会把被包含的jsp页面翻译成java代码</li>
<li>动态包含底层代码使用如下代码去调用被包含的jsp页面执行输出<br>
JspRuntimeLibraray.include(request,response,&quot;/include/footer.jsp&quot;, out, false);<br>
<em><strong>调用页面把自己的request，response，out对象都传递给了被调用页面去使用</strong></em></li>
<li>page属性是指定你要包含的jsp页面的路径</li>
<li>动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置</li>
<li><em><strong>动态包含还可以传递参数</strong></em></li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    // 主页面传参
    &lt;jsp:include page=&quot;/footer.jsp&quot;&gt;
        &lt;jsp:param name=&quot;username&quot; value=&quot;wyn&quot;&gt;
        &lt;jsp:param name=&quot;password&quot; value=&quot;root&quot;&gt;
    &lt;/jsp:include&gt;
    
    // 子页面获取参数
    &lt;%=request.getParameter('username')%&gt;
    &lt;%=request.getParameter('password')%&gt;</pre><pre class="hljs"><code>   <span class="hljs-comment"> // 主页面传参</span>
    &lt;jsp:<span class="hljs-built_in">include</span> page=<span class="hljs-string">&quot;/footer.jsp&quot;</span>&gt;
        &lt;jsp:<span class="hljs-built_in">param</span> name=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-built_in">value</span>=<span class="hljs-string">&quot;wyn&quot;</span>&gt;
        &lt;jsp:<span class="hljs-built_in">param</span> name=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-built_in">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;
    &lt;/jsp:<span class="hljs-built_in">include</span>&gt;
    
   <span class="hljs-comment"> // 子页面获取参数</span>
    &lt;%=request.getParameter(<span class="hljs-string">&#x27;username&#x27;</span>)%&gt;
    &lt;%=request.getParameter(<span class="hljs-string">&#x27;password&#x27;</span>)%&gt;</code></pre></div>
</li>
<li>jsp请求转发
<ul>
<li>以前是用servlet代码		&lt;%request.getRequestDispatcher(&quot;/scope2.jsp&quot;).forward(request,response);%&gt;<br>
来实现请求转发，现在可以通过jsp标签来实现</li>
<li><em><strong>&lt;jsp:forward page=&quot;/scope2.jsp&quot;&gt;&lt;/jsp:forward&gt;</strong></em></li>
</ul>
</li>
<li>&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;jsp标签形式请求转发<br>
和&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;si动态包含<br>
内部都是用&lt;jsp:param name=&quot;&quot; value=&quot;&quot;&gt;来传值给目标页面</li>
</ol>
<h3 id="什么是listener监听器">什么是Listener监听器？</h3>
<ul>
<li>Listener 是JavaEE三大组件之一。三大组件分别是：Servlet程序、Filter过滤器、Listener监听器。</li>
<li>Listener 监听器是JavaEE的规范之一。规范就是接口。所以Listener就是JavaEE中的接口。</li>
<li>监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户(程序)去做一些相应的处理。</li>
</ul>
<h3 id="servletcontextlistener监听器">ServletContextListener监听器</h3>
<ul>
<li>ServletContextListner可以监听ServletContext对象的创建和销毁。</li>
<li>ServletContext对象在web工程启动的时候创建，在web工程停止的时候销毁。</li>
<li>监听到创建和销毁之后都会分别调用ServletContextListner监听器的方法反馈。</li>
<li>两个方法分别是：<br>
在ServletContext对象创建之后马上调用，做初始化
<ol>
<li>public void contextInitialized(ServletContextEvent sce);<br>
在ServletContext对象销毁之后调用</li>
<li>public void contextDestroyed(ServletContextEvent sce);</li>
</ol>
</li>
<li>如何使用ServletContextListener监听器监听ServletContext对象。
<ol>
<li>编写一个类去实现ServletContextListener</li>
<li>实现其两个回调方法</li>
<li>到web.xml中去配置监听器<br>
<img src="../_resources/7c08867bf3194778b9a62713d94343e7.png" alt="c3b45b665a61a602c727682381b80e35.png"></li>
</ol>
</li>
</ul>
<h3 id="el表达式">EL表达式</h3>
<ul>
<li>EL表达式主要是在jsp页面中输出数据。代替jsp中的表达式脚本在jsp页面中进行数据的输出。</li>
<li>当EL表达式输出的为null时，页面中会显示为&quot;&quot;空串。</li>
<li>主要是输出域对象中的数据。pageContext，request，session，application</li>
<li>当四个域中都有相同的key的数据的时候，EL表达式会按照四个域的从小到大的优先级去输出。</li>
<li>EL表达式也可以输出Bean对象和Bean的属性(会根据属性名去寻找get方法，必须写get方法才可以输出)<br>
<img src="../_resources/cebb9e845e5048cabe3584d59ab1ddcf.png" alt="dd111beecf541e8ee54649b0eb4dde6c.png"></li>
</ul>
<h5 id="empty运算">empty运算</h5>
<p>empty运算可以判断一个数据是否为空，如果为空，则输出为true，不为空为false<br>
以下几种情况为空：</p>
<ol>
<li>值为null的时候，为空</li>
<li>值为空串的时候，为空</li>
<li>值为Object类型的数组，长度为零的时候</li>
<li>list集合，元素个数为零</li>
<li>map集合，元素个数为零</li>
</ol>
<h5 id="点运算和中括号运算符">&quot;.&quot;点运算和[]中括号运算符</h5>
<p>.点运算，可以输出Bean对象中某个属性的值,也可以输出Map集合中某个key对应的value<br>
[]中括号运算，可以输出有序集合中某个元素的值<br>
并且[]中括号运算，还可以输出map集合中key里含有特殊字符的key的值</p>
<h5 id="el表达式的11个隐含对象">EL表达式的11个隐含对象</h5>
<p>EL表达式中11个隐含对象，是EL表达式中自己定义的，可以直接使用。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageContext</td>
<td>pageContextImpl</td>
<td>它可以获取jsp中的九大内置对象</td>
</tr>
<tr>
<td>pageScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取pageContext域中的数据</td>
</tr>
<tr>
<td>requestScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Request域中的数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Session域中的数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取ServletContext域中的数据</td>
</tr>
<tr>
<td>param</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求参数的值</td>
</tr>
<tr>
<td>paramValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它也可以获取请求参数的值，获取多个值的时候使用</td>
</tr>
<tr>
<td>header</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求头的信息</td>
</tr>
<tr>
<td>headerValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求头的信息，它可以获取多个值的情况</td>
</tr>
<tr>
<td>cookie</td>
<td>Map&lt;String,Cookie&gt;</td>
<td>它可以获取当前请求的Cookie信息</td>
</tr>
<tr>
<td>intParam</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取在web.xml中配置的<context-param class="jop-noMdConv">上下文参数</td>
</tr>
</tbody>
</table>
<h5 id="el获取四个特定域中的属性">EL获取四个特定域中的属性</h5>
<p>pageScope		======		pageContext域<br>
requestScope   ======      Request域<br>
sessionScope   ======      Session域<br>
applicationScope =====     ServletContext域<br>
和获取对象属性一样</p>
<h5 id="el-pagecontext对象的使用">EL pageContext对象的使用</h5>
<ol>
<li>获取请求协议</li>
<li>获取请求的服务器ip或域名</li>
<li>获取请求的服务器端口</li>
<li>获取当前工程路径</li>
<li>获取请求方法(GET或POST)</li>
<li>获取客户端ip地址</li>
<li>获取会话的唯一标识</li>
</ol>
<ul>
<li>jsp获取方式</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">&lt;%= request.getScheme() %&gt; 
&lt;%= request.getServerName() %&gt; 
&lt;%= request.getServerPort() %&gt; 
&lt;%= request.getContextPath() %&gt; 
&lt;%= request.getMethod() %&gt; 
&lt;%= request.getRemoteHost() %&gt; 
&lt;%= session.getId() %&gt; </pre><pre class="hljs"><code>&lt;%= request.getScheme() %&gt; 
&lt;%= request.getServerName() %&gt; 
&lt;%= request.getServerPort() %&gt; 
&lt;%= request.getContextPath() %&gt; 
&lt;%= request.getMethod() %&gt; 
&lt;%= request.getRemoteHost() %&gt; 
&lt;%= session.getId() %&gt; </code></pre></div>
<ul>
<li>EL获取方式</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 企业开发的一个技巧，会把request对象放入pageContext域中
&lt;% pageContext.setAttribute(&quot;req&quot;, request) %&gt;
${req.scheme}
${req.serverName}
${req.serverPort}
${req.contextPath}
${req.method}
${req.remoteHost}
${pageContext.session.id}

${pageContext.request.scheme}
${pageContext.request.serverName}
${pageContext.request.serverPort}
${pageContext.request.contextPath}
${pageContext.request.method}
${pageContext.request.remoteHost}
${pageContext.session.id}</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 企业开发的一个技巧，会把request对象放入pageContext域中
&lt;% pageContext.setAttribute(<span class="hljs-string">&quot;req&quot;</span>, request) %&gt;
<span class="hljs-variable">${req.scheme}</span>
<span class="hljs-variable">${req.serverName}</span>
<span class="hljs-variable">${req.serverPort}</span>
<span class="hljs-variable">${req.contextPath}</span>
<span class="hljs-variable">${req.method}</span>
<span class="hljs-variable">${req.remoteHost}</span>
<span class="hljs-variable">${pageContext.session.id}</span>

<span class="hljs-variable">${pageContext.request.scheme}</span>
<span class="hljs-variable">${pageContext.request.serverName}</span>
<span class="hljs-variable">${pageContext.request.serverPort}</span>
<span class="hljs-variable">${pageContext.request.contextPath}</span>
<span class="hljs-variable">${pageContext.request.method}</span>
<span class="hljs-variable">${pageContext.request.remoteHost}</span>
<span class="hljs-variable">${pageContext.session.id}</span></code></pre></div>
<h5 id="el-表达式其他隐含对象的使用">EL 表达式其他隐含对象的使用</h5>
<ul>
<li>param和paramValues用来输出请求参数</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 请求地址：http://localhost:8080/09_EL_JSTL/other_el_obj.jsp?username=wzg168&amp;password=666666&amp;hobby=java&amp;hobby=cpp
输出请求参数 username 的值：${ param.username } &lt;br&gt;
输出请求参数 password 的值：${ param.password } &lt;br&gt;
输出请求参数 hobby 的值：${ paramValues.hobby[0] } &lt;br&gt;
输出请求参数 hobby 的值：${ paramValues.hobby[1] } &lt;br&gt;</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 请求地址：http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/09_EL_JSTL/</span>other_el_obj.jsp?username=wzg168&amp;password=<span class="hljs-number">666666</span>&amp;hobby=java&amp;hobby=cpp
输出请求参数 username 的值：<span class="hljs-variable">${ param.username }</span> &lt;br&gt;
输出请求参数 password 的值：<span class="hljs-variable">${ param.password }</span> &lt;br&gt;
输出请求参数 hobby 的值：<span class="hljs-variable">${ paramValues.hobby[0] }</span> &lt;br&gt;
输出请求参数 hobby 的值：<span class="hljs-variable">${ paramValues.hobby[1] }</span> &lt;br&gt;</code></pre></div>
<ul>
<li>header和headerValues用来输出请求头</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">输出请求头【User-Agent】的值：${ header['User-Agent'] } &lt;br&gt;
输出请求头【Connection】的值：${ header.Connection } &lt;br&gt;
输出请求头【User-Agent】的值：${ headerValues['User-Agent'][0] } &lt;br</pre><pre class="hljs"><code>输出请求头【<span class="hljs-keyword">User</span>-Agent】的值：${ <span class="hljs-keyword">header</span>[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] } &lt;br&gt;
输出请求头【<span class="hljs-keyword">Connection</span>】的值：${ <span class="hljs-keyword">header</span>.<span class="hljs-keyword">Connection</span> } &lt;br&gt;
输出请求头【<span class="hljs-keyword">User</span>-Agent】的值：${ headerValues[<span class="hljs-string">&#x27;User-Agent&#x27;</span>][<span class="hljs-number">0</span>] } &lt;br</code></pre></div>
<ul>
<li>cookie Map&lt;String, Cookie&gt; 用来获取当前请求的cookie信息</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">获取 Cookie 的名称：${ cookie.JSESSIONID.name } &lt;br&gt;
获取 Cookie 的值：${ cookie.JSESSIONID.value } &lt;br</pre><pre class="hljs"><code>获取 Cookie 的名称：${ cookie<span class="hljs-selector-class">.JSESSIONID</span><span class="hljs-selector-class">.name</span> } &lt;br&gt;
获取 Cookie 的值：${ cookie<span class="hljs-selector-class">.JSESSIONID</span><span class="hljs-selector-class">.value</span> } &lt;br</code></pre></div>
<ul>
<li>initParam 用来获取在web.xml中配置的<context-param class="jop-noMdConv">上下文参数<br>
web.xml中配置<context-param class="jop-noMdConv">上下文参数：</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">&lt;context-param&gt;
    &lt;param-name&gt;username&lt;/param-name&gt;
    &lt;param-value&gt;root&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:mysql:///test&lt;/param-value&gt;
&lt;/context-param&gt;</pre><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql:///test<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>
<p>EL表达式输出配置的上下文参数</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">输出&lt;Context-param&gt;username 的值：${ initParam.username } &lt;br&gt;
输出&lt;Context-param&gt;url 的值：${ initParam.url } &lt;br&gt;</pre><pre class="hljs"><code><span class="language-xml">输出<span class="hljs-tag">&lt;<span class="hljs-name">Context-param</span>&gt;</span>username 的值：$</span><span class="hljs-template-variable">{ initParam.username }</span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
输出<span class="hljs-tag">&lt;<span class="hljs-name">Context-param</span>&gt;</span>url 的值：$</span><span class="hljs-template-variable">{ initParam.url }</span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span></code></pre></div>
<h3 id="jstl表达式和文件上传和下载详见尚硅谷笔记">JSTL表达式和文件上传和下载详见尚硅谷笔记</h3>
<h3 id="利用反射使请求可以映射到对应servlet里的对应方法"><em><strong>利用反射</strong></em>使<em><strong>请求</strong></em>可以<em><strong>映射到</strong></em>对应Servlet里的对应<em><strong>方法</strong></em></h3>
<pre><code>尚硅谷JavaWeb p227 p228 
web.xml中配置的是子类servlet程序的请求地址，所以是先找子类servlet程序，子类再调用父类(BaseServlet)中的doPost()方法，而BaseServlet中的doPost方法是由子类对象调用的(自始至终都只有子类这一个对象)，所以this指的是子类servlet对象，所以利用this反射的时候反射出来的是子类及子类的方法。
</code></pre>
<h3 id="cookie">Cookie</h3>
<h4 id="什么是cookie">什么是Cookie？</h4>
<ol>
<li>Cookie是由服务器通知客户端保存键值对的一种技术</li>
<li>客户端有了Cookie后，每次请求都发送给服务器。</li>
<li>每个Cookie的大小不能超过4kb。</li>
<li>【Cookie保存在客户端(浏览器)，请求里面请求头发送cookie，响应里面Set-Cookie增or改cookie】</li>
</ol>
<h4 id="cookie到底是怎么回事">Cookie到底是怎么回事？</h4>
<p>很简单，Cookie就是服务器创建cookie键值对，然后通知客户端保存这个键值对，然后客户端通过每次请求中请求头携带所有cookie键值对发送给服务器。服务器再调方法获取到cookies。<br>
<img src="../_resources/c859867061a34533be55acb606b401ba.png" alt="da6b0e8613a216631a90a59eb8c3b68b.png"></p>
<h4 id="服务器端如何创建cookie给客户端">服务器端如何创建Cookie给客户端？</h4>
<p><img src="../_resources/7185b96d17614da692a9f2bb09ffa9c9.jpg" alt="304313ca613e6e528030f662f79d5252.jpg"></p>
<h4 id="服务器端如何修改客户端的cookie">服务器端如何修改客户端的Cookie？</h4>
<blockquote>
<p>方案一：</p>
<ol>
<li>先创建一个要修改的同名的Cookie对象，Cookie cookie = new Cookie(&quot;key1&quot;， &quot;newValue1&quot;);</li>
<li>调用 response.addCookie(cookie); 通知客户端保存此cookie。客户端(浏览器)会先看一眼自己有没有同名(name值相同)的cookie，若没有则创建，若有则覆盖修改。</li>
</ol>
</blockquote>
<blockquote>
<p>方案二:</p>
<ol>
<li>先查找到需要修改的Cookie对象，调用setValue()方法赋予新的Cookie值。最后调用response.addCookie(cookie)通知客户端保存修改后的cookie。</li>
</ol>
</blockquote>
<h4 id="服务器如何获取客户端每次请求发送过来的cookie">服务器如何获取客户端每次请求发送过来的Cookie？</h4>
<ul>
<li>获取全部Cookie<br>
Cookie[] cookies = req.getCookies();</li>
<li>遍历获得根据Cookie的name属性判断，获取指定cookie<br>
<img src="../_resources/fb1449bb6ac7412cbd122d9767b0d273.png" alt="f79ca24781a982d53d8de60dbb8a940d.png"></li>
<li>CookieUtiles工具类api获取，原理和前面两种一样(自己写一个循环遍历根据name返回指定cookie封装成方法)</li>
</ul>
<h4 id="cookie的生命周期">Cookie的生命周期</h4>
<p>Cookie的生命周期指的是如何管理Cookie什么时候被销毁<br>
主要由setMaxAge()控制<br>
setMaxAge()<br>
设置cookie的最大生存时间<br>
正值：表示在指定的秒数后过期<br>
负值：表示浏览器一关，cookie就会被删除(默认值是-1)<br>
零：表示立刻删除cookie</p>
<h4 id="cookie有效路径path的设置">Cookie有效路径Path的设置</h4>
<p>Cookie的path属性可以有效的过滤哪些cookie发送给服务器，哪些不发。<br>
path属性是通过请求的地址来进行有效的过滤。<br>
假如设	cookie.setPath(req.getContextPath() + &quot;/abc&quot;);<br>
那么	只有 请求地址为当前工程路径/abc下的请求会存在该cookie并发送<br>
请求地址为当前工程路径下(没有/abc)的请求不存在该cookie也不会发送该cookie<br>
<img src="../_resources/7eb486ad78ab45fb91e26860cf1cdbad.png" alt="81e4cd8a1ec904cc840206a586c65106.png"></p>
<h4 id="cookie实现免用户名登录">Cookie实现免用户名登录</h4>
<p><img src="../_resources/7a3dec2a99564058b4af9ddc9b3639f4.png" alt="7116d422c7e9d9218e36dfea0b7c4816.png"><br>
1、 第一次客户端访问浏览器登录页面，客户端输入账号密码后点击提交按钮<br>
2、 发送请求给服务器，服务器获取到客户端提交的用户名和密码后判断是否正确。正确：允许登录，并且把用户名通过响应set-cookie给客户端保存(Cookie cookie = new Cookie(&quot;username&quot;, &quot;wangyingnan&quot;); response.addCookie(cookie);)<br>
3、 浏览器有了用户名的Cookie信息后，第二次访问登录页面时，会通过请求把cookie信息也发送给服务器，服务器返回回显了用户名的登录页面(可以用EL表达式显示，${cookie.username.value})。</p>
<h3 id="session">Session</h3>
<h4 id="什么是session">什么是Session？</h4>
<p>1、Session就是一个接口(<strong>HttpSession</strong>)。<br>
2、Session就是会话。<strong>它是用来维护一个客户端和服务器关联的一种技术。</strong><br>
3、 每个客户端都有自己的一个Session会话。<br>
4、 <strong>Session会话中，我们经常用来保存用户登录之后的信息</strong>。<br>
5、 <strong>Cookie是保存在客户端，而Session会话是保存在服务器端</strong>。</p>
<h4 id="session的作用">Session的作用?</h4>
<p><strong>通过Session把客户端的信息保存到服务器内。</strong></p>
<h4 id="如何创建和获取sessionid号是否为新">如何创建和获取Session？(id号，是否为新)</h4>
<p>如何创建和获取Session。创建和获取Session的API是一样的。<br>
<em><strong>request.getSession()</strong></em><br>
第一次调用是：创建Session会话<br>
之后调用都是：获取前面创建好的Session会话对象。</p>
<p>session.isNew(): 判断到底是不是刚创建出来的(新创建的)<br>
true 表示刚创建<br>
flase 表示获取之前创建</p>
<p><em><strong>每个会话都有一个ID值(身份证号)。而且这个ID值是唯一的。</strong></em><br>
session.getId()得到Session的会话ID值。</p>
<h4 id="session域中的存取">Session域中的存取</h4>
<p>存键值对setAttribute()<br>
取键值对getAttribute()<br>
删键值对removeAttribute()</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;);
req.getSession().getAttribute(&quot;key1&quot;);
req.getSession().removeAttribute(&quot;key1&quot;);</pre><pre class="hljs"><code>req.get<span class="hljs-constructor">Session()</span>.set<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>)</span>;
req.get<span class="hljs-constructor">Session()</span>.get<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;key1&quot;</span>)</span>;
req.get<span class="hljs-constructor">Session()</span>.remove<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;key1&quot;</span>)</span>;</code></pre></div>
<h4 id="session-生命周期控制">Session 生命周期控制</h4>
<ul>
<li>public void setMaxInactiveInterval(int interval) <strong>设置Session的超时时间(以秒为单位)</strong>，超过指定的时长，Session就会被销毁。<br>
值为正数的时候，设定Session的超时时长。<br>
负数表示用不超时(极少使用)。如果设置为不超时的话，服务器这边就会有越来越多的Session，就会很危险了，容易内存溢出。</li>
<li>public int getMaxInactiveInterval() <strong>获取Session的超时时间</strong></li>
<li><strong>Session的默认超时时长是30分钟</strong>。<br>
因为在Tomcat服务器的配置文件web.xml中默认有以下配置：<br>
<img src="../_resources/65d3f6dfaa3f418199885057836ec52e.png" alt="1c2d8427b9dbf9cd952d829ddf3f9d9d.png"><br>
它表示配置在当前Tomcat服务器下的所有web工程的Session超时默认时长都为30分钟。</li>
<li>如果想更改整个web工程的Session的默认超时时长，可以到自己的web工程中的web.xml里配置Session的超时时长。</li>
<li>如果只想修改个别Session的超时时长。就可以使用上面的API(方法)setMaxInactiveInterval(int interval)来进行单独的设置。</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 先获取到Session对象
HttpSession session = req.getSession();
// 设置当前Session3秒后超时
session.setMaxInactiveInterval(3);</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 先获取到Session对象
HttpSession session = req.getSession();
<span class="hljs-regexp">//</span> 设置当前Session3秒后超时
session.setMaxInactiveInterval(<span class="hljs-number">3</span>);</code></pre></div>
<ul>
<li>
<p><strong>Session超时指的是，客户端两次请求的最大间隔时长</strong>。</p>
</li>
<li>
<p>MaxInactiveInterval(int interval)指的是最大非活动时间间隔，e.g.如果你一直狂点狂发请求，那么Session的生命周期不不断的重置为3秒，永远不会过期，3秒真男人。</p>
</li>
<li>
<p>public void invalidate()</p>
</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 让session对话马上销毁
session.invalidate();</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 让session对话马上销毁
session.invalidate();</code></pre></div>
<p>让当前Session会话马上超时无效。</p>
<h4 id="浏览器和session之间关联的技术内幕">浏览器和Session之间关联的技术内幕</h4>
<p><strong>Session技术，底层其实是基于Cookie技术来实现的。</strong><br>
客户端(浏览器)-&gt;服务器(Tomcat)</p>
<ol>
<li>首先浏览器没有任何Cookie的信息</li>
<li>在没有cookie的情况下，浏览器发请求，服务器则会默认调用request.getSession()方法第一次创建Session会话对象</li>
<li>服务器每次创建出Session会话对象的时候，都会创建一个Cookie对象。这个Cookie对象的key永远是: JESSIONID，值是新创建出来的Session的id值。</li>
<li>服务器通过响应把新创建出来的Session的id值返回给客户端。(Set-Cookie: JSESSIONID=xxxxxxxxx)</li>
<li>客户端有了Cookie之后，每次请求，都会把Session的id以Cookie的形式发送给服务器。(Cookie:JSESSIONID=xxxxxxxx)</li>
<li>服务器再次调用request.getSession()方法，不过这次服务器接收到cookie中保存的Session的id值后，会找到之前创建好的Session对象并返回。<br>
<img src="../_resources/4858dd7709204bd9b8439d284f5ecfc7.jpg" alt="6289b3b7bac083712a5b228220d9cd69.jpg"></li>
<li>若删除掉保存Session id 的 cookie，客户端发送请求，那么服务器调用request.getSession()时由于没有接收到Session的id，所以服务器又回创建出一个Session会话，且伴随着创建一个cookie对象。再通过响应把set-cookie给客户端，客户端接收到cookie后就有了新的Session Id，再发请求时，把此cookie发给客户端，客户端通过session id 找到之前创建的Session并返回。</li>
</ol>
<h4 id="为什么说每次打开浏览器会创建一个session每次关闭浏览器session就没有了">为什么说每次打开浏览器会创建一个Session，每次关闭浏览器Session就没有了？</h4>
<p><strong>因为每次关闭浏览器，cookie就没有了，所以就没有了SesisonID，所以浏览器找不到之前创建的Session对象不论这个Session对象被没被真正销毁，每次打开浏览器都会重新创建一个Session对象。</strong></p>
<h3 id="用户登录">用户登录</h3>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">public void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
    String username = req.getParameter(&quot;username&quot;);	
    String password = req.getParameter(&quot;password&quot;);	

    if (&quot;disillusion021&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) {
        // 登录成功
        // 把用户名保存到cookie中
        Cookie cookie = new Cookie(&quot;username&quot;, &quot;disillusion021&quot;);
        // 设置cookie可以保存一天
        cookie.setMaxAge(24 * 60 * 60);
        // 通知客户端保存cookie
        response.addCookie(cookie);
        // 保存用户登录信息到Session域中
        req.getSession().setAttribute(&quot;user&quot;, loginUser);
        resultVO.setMsg(&quot;登录成功&quot;);
    } else {
        // 登录失败
        resultVO.setMsg(&quot;登录失败&quot;);
    }
}</pre><pre class="hljs"><code>public void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
    String username = req.get<span class="hljs-constructor">Parameter(<span class="hljs-string">&quot;username&quot;</span>)</span>;	
    String password = req.get<span class="hljs-constructor">Parameter(<span class="hljs-string">&quot;password&quot;</span>)</span>;	

    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;disillusion021&quot;</span>.equals(username)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-string">&quot;123456&quot;</span>.equals(password)) {
        <span class="hljs-comment">// 登录成功</span>
        <span class="hljs-comment">// 把用户名保存到cookie中</span>
        Cookie cookie = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Cookie(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;disillusion021&quot;</span>)</span>;
        <span class="hljs-comment">// 设置cookie可以保存一天</span>
        cookie.set<span class="hljs-constructor">MaxAge(24 <span class="hljs-operator">*</span> 60 <span class="hljs-operator">*</span> 60)</span>;
        <span class="hljs-comment">// 通知客户端保存cookie</span>
        response.add<span class="hljs-constructor">Cookie(<span class="hljs-params">cookie</span>)</span>;
        <span class="hljs-comment">// 保存用户登录信息到Session域中</span>
        req.get<span class="hljs-constructor">Session()</span>.set<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-params">loginUser</span>)</span>;
        resultVO.set<span class="hljs-constructor">Msg(<span class="hljs-string">&quot;登录成功&quot;</span>)</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 登录失败</span>
        resultVO.set<span class="hljs-constructor">Msg(<span class="hljs-string">&quot;登录失败&quot;</span>)</span>;
    }
}</code></pre></div>
<blockquote>
<p>页面中可以用${cookie.username.value}在第二次登录时来显示用户名</p>
</blockquote>
<h4 id="显示登录的用户信息">显示登录的用户信息</h4>
<p><strong>用Session保存用户的登录信息，因为多个页面都要使用到用户名等信息，所以request域小了，要使用Session域来保存</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">req.getSession.setAttribute(&quot;user&quot;, loginUser);</pre><pre class="hljs"><code>req.getSession.set<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-params">loginUser</span>)</span>;</code></pre></div>
<blockquote>
<p>所有页面中可以用${sessionScope.user.username}来显示用户信息</p>
</blockquote>
<h4 id="登出-注销用户">登出---注销用户</h4>
<ul>
<li>销毁Session中用户登录的信息(或者直接销毁Session)</li>
</ul>
<h3 id="表单重复提交及解决方案">表单重复提交及解决方案</h3>
<h4 id="表单重复提交有三种常见的情况">表单重复提交有三种常见的情况：</h4>
<ul>
<li>一：提交完表单，服务器使用请求转发来进行页面跳转。这个时候，用户按下功能键F5，就会发起最后一次的请求，造成表单重复提交问题。解决方法: <strong>使用重定向进行跳转</strong>。因为重定向相当于发两次请求，F5只刷新最后一次请求，所以不会有表单重复提交的问题。</li>
<li>二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败，就会着急，然后多点了几次提交操作，也会造成表单重复提交。</li>
<li>三：用户正常提交服务器，服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复提交。<strong>后两种情况，可以用验证码的方式来解决</strong></li>
</ul>
<h4 id="验证码解决表单重复提交">验证码解决表单重复提交</h4>
<ul>
<li>当第一次访问regist.jsp时，服务器端就会生成验证码，并且保存到Session中，并且以图像格式显示给客户端</li>
<li>当第一次提交表单时，服务器获取到客户端所提交的验证码，和存取到Session中的验证码进行比较，如果相等，返回登陆成功页面，如果不相等，返回登录失败页面。</li>
<li>比较完后立即删除 Session 中的验证码，这样当第二次重复提交时(多点好几下或回退页面重新提交) ，此时服务器端Session中的验证码已经为null，此时的话就阻止用户的操作(解决了表单重复提交的问题)。<br>
<img src="../_resources/71534bf2a0f549c6a4d97b6e34221909.jpg" alt="0b4d1ea3a410a636d7f95df50800b956.jpg"></li>
</ul>
<h4 id="谷歌kaptcha图片验证码的使用">谷歌kaptcha图片验证码的使用</h4>
<p>谷歌验证码的使用步骤如下：</p>
<ol>
<li>导入谷歌验证码的jar包： kaptcha-2.3.2.jar</li>
<li>在web.xml中去配置用于生成验证码的Servlet程序<br>
<img src="../_resources/e9edf28acc12434fbdebd4bdc4c1c6da.png" alt="01f8e908dc26ff749b4bbc596ff44d22.png"></li>
<li>在表单中使用img标签去显示验证码图片并使用它<img src="../_resources/bee0f0a206174bbf82bce2e40cb53424.png" alt="2be3ca6338a9286f8ed9b30deb1d5672.png"></li>
<li>在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用。</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    // 获取Session中的验证码
    String token  = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);
    // 删除Session中的验证码
    req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);
    // 获取页面提交(用户填入)的验证码
    String code = req.getParameter(&quot;code&quot;);
    // 比较Session中存放的验证码也就是页面上显示的图片验证码 与 页面提交(用户填入)的验证码是否一致
    if (token != null &amp;&amp; token.equalsIgnoreCase(code)) {
        System.out.println(&quot;保存到数据库:&quot; + req.getParameter(&quot;username&quot;));
        resp.sendRedirect(req.getContextPath() + &quot;/ok.jsp&quot;);
    } else {
        resp.sendRedirect(req.getContextPath() + &quot;/fail.jsp&quot;);
    }</pre><pre class="hljs"><code>    <span class="hljs-comment">// 获取Session中的验证码</span>
    String token  = (String) req.get<span class="hljs-constructor">Session()</span>.get<span class="hljs-constructor">Attribute(KAPTCHA_SESSION_KEY)</span>;
    <span class="hljs-comment">// 删除Session中的验证码</span>
    req.get<span class="hljs-constructor">Session()</span>.remove<span class="hljs-constructor">Attribute(KAPTCHA_SESSION_KEY)</span>;
    <span class="hljs-comment">// 获取页面提交(用户填入)的验证码</span>
    String code = req.get<span class="hljs-constructor">Parameter(<span class="hljs-string">&quot;code&quot;</span>)</span>;
    <span class="hljs-comment">// 比较Session中存放的验证码也就是页面上显示的图片验证码 与 页面提交(用户填入)的验证码是否一致</span>
    <span class="hljs-keyword">if</span> (token != null<span class="hljs-operator"> &amp;&amp; </span>token.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">code</span>)</span>) {
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;保存到数据库:&quot;</span> + req.get<span class="hljs-constructor">Parameter(<span class="hljs-string">&quot;username&quot;</span>)</span>);
        resp.send<span class="hljs-constructor">Redirect(<span class="hljs-params">req</span>.<span class="hljs-params">getContextPath</span>()</span> + <span class="hljs-string">&quot;/ok.jsp&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        resp.send<span class="hljs-constructor">Redirect(<span class="hljs-params">req</span>.<span class="hljs-params">getContextPath</span>()</span> + <span class="hljs-string">&quot;/fail.jsp&quot;</span>);
    }</code></pre></div>
<ol start="5">
<li>验证码的切换：只需要给验证码img标签加上点击事件设置src属性重新发送请求获取新验证码即可。<br>
<img src="../_resources/b90c41ec02584781ab0263906853dc11.png" alt="9367273f2dc3de0b04968102f8a7b13d.png"></li>
<li>若验证码不切换，可能是浏览器的缓存导致的。</li>
</ol>
<ul>
<li>浏览器请求的缓存名称：由最后的资源名和参数组成。</li>
<li>浏览器为了让请求速度更快。就会把每次请求的内容缓存到了浏览器端(要吗硬盘中，要吗内存中)。</li>
<li>再发一样地址和参数的请求时，浏览器就会直接从缓存中找。</li>
<li>为了跳过浏览器的缓存而发起请求，可以在每次请求后面加一个随机参数。如 + new Date();</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">this.src = &quot;${basePath}kaptcha.jpg?d=&quot; + new Date();</pre><pre class="hljs"><code><span class="hljs-keyword">this</span>.src = <span class="hljs-string">&quot;<span class="hljs-subst">${basePath}</span>kaptcha.jpg?d=&quot;</span> + <span class="hljs-keyword">new</span> Date();</code></pre></div>
<h3 id="购物车的实现">购物车的实现</h3>
<p><img src="../_resources/0198d01759d44b1b92c3e2a76716a091.jpg" alt="8af01e5cbbf8ce9367973458fdb8c12b.jpg"></p>
<h4 id="市面上购物车的实现技术版本有">市面上购物车的实现技术版本有：</h4>
<h5 id="session版本把购物车信息保存到session域中">Session版本(把购物车信息保存到Session域中)</h5>
<p><img src="../_resources/f7fc1884759b41e7874b23435b63ff60.png" alt="94e90b4403020b7efcad7a90a85b4c31.png"><br>
<img src="../_resources/922fda56887b4c0c886ae1d75c0191d9.png" alt="8e3aea7b34b174005e2687d1ff3db6f4.png"></p>
<h5 id="数据库版本把购物车信息保存到数据库">数据库版本(把购物车信息，保存到数据库)</h5>
<h5 id="redis数据库cookie使用cookieredis缓存和数据库">redis+数据库+Cookie(使用Cookie+Redis缓存，和数据库)</h5>
<h3 id="filter">Filter</h3>
<h4 id="filter-什么是过滤器">Filter 什么是过滤器？</h4>
<ol>
<li>Filter 过滤器它是 JavaWeb 的三大组件之一。</li>
<li>Filter 过滤器它是 JavaEE 发的规范。 也就是接口。</li>
</ol>
<h4 id="filter-的作用">Filter 的作用</h4>
<p>Filter 过滤器它的作用是：<strong>拦截请求</strong>，过滤响应。<br>
拦截请求的应用场景有：权限检查 日志操作 事务管理 等等</p>
<h4 id="filter初体验权限检查">Filter初体验：权限检查</h4>
<p>要求在你的web工程下，有一个admin目录。这个admin目录下的所有资源(html页面、jsp文件、jpg图片、等等)都必须是用户登录之后才允许访问。</p>
<p>思考：根据之前我们学过的内容。我们知道，<em><strong>用户登录之后都会把用户登录的信息系保存到Session域中。所以要检查用户是否登录，可以判断Session中是否包含有用户的信息即可</strong></em>！！！</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="jsp" data-joplin-source-open="```jsp&#10;" data-joplin-source-close="&#10;```">&lt;%
    Object user = session.getAttribute(&quot;user&quot;);
    // 如果session中没保存有用户登录信息，说明用户还没有登录
    if (user == null) {
        // 请求转发，跳转到用户登录页面
        request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
        return;
    }
%&gt;</pre><pre class="hljs"><code>&lt;%
    <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);
    <span class="hljs-comment">// 如果session中没保存有用户登录信息，说明用户还没有登录</span>
    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 请求转发，跳转到用户登录页面</span>
        request.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(request, response);
        <span class="hljs-keyword">return</span>;
    }
%&gt;</code></pre></div>
<p><strong>但是这种方案只能用在jsp资源中去校验用户是否登录，不能用在html,jpg等资源中，有局限性</strong>。<br>
<strong>但Filter可以用于各种资源的权限管理</strong></p>
<h4 id="过滤器的大致原理">过滤器的大致原理</h4>
<p><img src="../_resources/9f20e43e5a114b1dbffcf68f9701d350.png" alt="1c450c7150983b0e087f8cf96c113982.png"></p>
<h4 id="过滤器的代码实现">过滤器的代码实现</h4>
<ol>
<li>写一个过滤器类继承Filter接口</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class AdminFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    /**
     * doFilter方法, 专门用于拦截请求和过滤响应，这里主要演示拦截请求。可以做权限检查。
     * @param request
     * @param response
     * @param chain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpSession session = httpServletRequest.getSession();
        Object user = session.getAttribute(&quot;user&quot;);
        if (user == null) {
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            return;
        } else {
            // 让程序继续往下访问用户的目标资源。
            chain.doFilter(request, response);
        }
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException {
        Filter.<span class="hljs-built_in">super</span>.init(filterConfig);
    }

    <span class="hljs-comment">/**
     * doFilter方法, 专门用于拦截请求和过滤响应，这里主要演示拦截请求。可以做权限检查。
     * <span class="hljs-doctag">@param</span> request
     * <span class="hljs-doctag">@param</span> response
     * <span class="hljs-doctag">@param</span> chain
     * <span class="hljs-doctag">@throws</span> IOException
     * <span class="hljs-doctag">@throws</span> ServletException
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException {
        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpServletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;
        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> httpServletRequest.getSession();
        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            request.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(request, response);
            <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 让程序继续往下访问用户的目标资源。</span>
            chain.doFilter(request, response);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        Filter.<span class="hljs-built_in">super</span>.destroy();
    }
}</code></pre></div>
<ol start="2">
<li>在web.xml中配置过滤器的拦截路径</li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    &lt;!--filter标签用于配置一个Filter过滤器--&gt;
    &lt;filter&gt;
        &lt;!--给filter起一个别名--&gt;
        &lt;filter-name&gt;adminFilter&lt;/filter-name&gt;
        &lt;!--配置filter的全类名--&gt;
        &lt;filter-class&gt;com.coding.filter.AdminFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;email&lt;/param-name&gt;
            &lt;param-value&gt;171451721@qq.com&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;address&lt;/param-name&gt;
            &lt;param-value&gt;春柳&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt;
    &lt;filter-mapping&gt;
        &lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt;
        &lt;filter-name&gt;adminFilter&lt;/filter-name&gt;
        &lt;!--url-pattern表示配置拦截路径--&gt;
        &lt;!--/ 表示请求地址为：http://ip:port/工程路径/  映射到idea的web目录--&gt;
        &lt;!--/admin/* 表示请求地址为 http://ip:port/工程路径/admin/* --&gt;
        &lt;url-pattern&gt;/ad/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</pre><pre class="hljs"><code>    <span class="hljs-comment">&lt;!--filter标签用于配置一个Filter过滤器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
        <span class="hljs-comment">&lt;!--给filter起一个别名--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>adminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
        <span class="hljs-comment">&lt;!--配置filter的全类名--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.coding.filter.AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>email<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>171451721@qq.com<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>address<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>春柳<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-comment">&lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
        <span class="hljs-comment">&lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>adminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
        <span class="hljs-comment">&lt;!--url-pattern表示配置拦截路径--&gt;</span>
        <span class="hljs-comment">&lt;!--/ 表示请求地址为：http://ip:port/工程路径/  映射到idea的web目录--&gt;</span>
        <span class="hljs-comment">&lt;!--/admin/* 表示请求地址为 http://ip:port/工程路径/admin/* --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/ad/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div>
<h4 id="filter过滤器的使用步骤">Filter过滤器的使用步骤:</h4>
<p>1、编写一个类去实现Filter接口<br>
2、实现过滤方法doFIlter();<br>
3、到web.xml中去配置Filter的拦截路径</p>
<h4 id="filter的生命周期">Filter的生命周期</h4>
<p>Filter的生命周期包含几个方法<br>
1、构造器方法<br>
2、init初始化方法<br>
第1,2步，在web工程启动的时候执行(Filter已经创建)<br>
3、doFilter过滤方法<br>
第3步，<strong>每次</strong>拦截到请求，就会执行<br>
4、destroy销毁<br>
第4步，停止web工程的时候，就会执行(停止web工程，也会销毁Filter过滤器)</p>
<h4 id="filterconfig类">FilterConfig类</h4>
<p>FilterConfig类的作用是获取filter过滤器的配置内容。<br>
Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，这里包含了Filter配置文件的配置信息。<br>
1、获取Filter的名称 filter-name 的内容<br>
2、获取web.xml中配置的init-param初始化参数<br>
3、获取ServletContext对象</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class AdminFilter implements Filter {
    public AdminFilter() {
        System.out.println(&quot;1. 先执行AdminFilter()构造器方法&quot;);
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;2. 再执行init(FilterConfig filterConfig)初始化方法&quot;);
        Filter.super.init(filterConfig);
        // 1、获取Filter的名称 filter-name 的内容
        System.out.println(&quot;Filter的名称是：&quot; + filterConfig.getFilterName());
        // 2、获取web.xml中配置的init-param初始化参数
        System.out.println(&quot;初始化参数email的值是：&quot; + filterConfig.getInitParameter(&quot;email&quot;));
        System.out.println(&quot;初始化参数address的值是：&quot; + filterConfig.getInitParameter(&quot;address&quot;));
        // 3、获取ServletContext对象
        System.out.println(&quot;获取ServletContext对象&quot; + filterConfig.getServletContext());
    }

    /**
     * doFilter方法, 专门用于拦截请求。可以做权限检查。
     * @param request
     * @param response
     * @param chain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;3. 再执行Filter的doFilter(ServletRequest request, ServletResponse response, FilterChain chain)过滤方法&quot;);
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpSession session = httpServletRequest.getSession();
        Object user = session.getAttribute(&quot;user&quot;);
        if (user == null) {
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response);
            return;
        } else {
            // 让程序继续往下访问用户的目标资源。
            chain.doFilter(request, response);
        }
    }

    @Override
    public void destroy() {
        System.out.println(&quot;4. 最后执行Filter的destroy()方法&quot;);
        Filter.super.destroy();
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminFilter</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">&quot;1. 先执行AdminFilter()构造器方法&quot;</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException {
        System.out.println(<span class="hljs-string">&quot;2. 再执行init(FilterConfig filterConfig)初始化方法&quot;</span>);
        Filter.<span class="hljs-built_in">super</span>.init(filterConfig);
        <span class="hljs-comment">// 1、获取Filter的名称 filter-name 的内容</span>
        System.out.println(<span class="hljs-string">&quot;Filter的名称是：&quot;</span> + filterConfig.getFilterName());
        <span class="hljs-comment">// 2、获取web.xml中配置的init-param初始化参数</span>
        System.out.println(<span class="hljs-string">&quot;初始化参数email的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;email&quot;</span>));
        System.out.println(<span class="hljs-string">&quot;初始化参数address的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;address&quot;</span>));
        <span class="hljs-comment">// 3、获取ServletContext对象</span>
        System.out.println(<span class="hljs-string">&quot;获取ServletContext对象&quot;</span> + filterConfig.getServletContext());
    }

    <span class="hljs-comment">/**
     * doFilter方法, 专门用于拦截请求。可以做权限检查。
     * <span class="hljs-doctag">@param</span> request
     * <span class="hljs-doctag">@param</span> response
     * <span class="hljs-doctag">@param</span> chain
     * <span class="hljs-doctag">@throws</span> IOException
     * <span class="hljs-doctag">@throws</span> ServletException
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException {
        System.out.println(<span class="hljs-string">&quot;3. 再执行Filter的doFilter(ServletRequest request, ServletResponse response, FilterChain chain)过滤方法&quot;</span>);
        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpServletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;
        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> httpServletRequest.getSession();
        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) {
            request.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(request, response);
            <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 让程序继续往下访问用户的目标资源。</span>
            chain.doFilter(request, response);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">&quot;4. 最后执行Filter的destroy()方法&quot;</span>);
        Filter.<span class="hljs-built_in">super</span>.destroy();
    }
}</code></pre></div>
<h4 id="filterchain-过滤器链">FilterChain 过滤器链</h4>
<p>FilterChain 就是 过滤器链（多个过滤器如何一起工作）<br>
<strong>FilterChain.doFilter()方法</strong>用在Filter.doFilter()方法内，其有两个作用</p>
<ul>
<li>执行下一个Filter过滤器（如果有Filter）</li>
<li>执行目标资源（没有Filter）<br>
<img src="../_resources/9c31ede2c2af474aaaebc8e90360f645.png" alt="0315b8d61355701334074a6c952cbf46.png"><br>
<strong>在多个Filter过滤器执行的时候，它们执行的优先顺序是由它们在web.xml中从上到下配置的顺序决定。</strong></li>
<li>多个过滤器执行的特点：
<ol>
<li>所有Filter和目标资源默认都执行在同一个线程中。</li>
<li>多个Filter共同执行的时候，它们都使用同一个Request对象。因为是同一次请求。</li>
</ol>
</li>
</ul>
<h4 id="filter的拦截路径">Filter的拦截路径</h4>
<ul>
<li>精确匹配<br>
&lt;url-pattern&gt;/target.jsp&lt;url-pattern&gt;<br>
以上配置的路径，表示请求地址必须为：<a data-from-md title='http://ip' href='http://ip'>http://ip</a>:port/工程路径/target.jsp</li>
<li>目录匹配<br>
&lt;url-pattern&gt;/admin/*&lt;url-pattern&gt;<br>
以上配置的路径，表示请求地址必须为：<a data-from-md title='http://ip' href='http://ip'>http://ip</a>:port/工程路径/admin/*</li>
<li>后缀名匹配<br>
&lt;url-pattern&gt;*.html&lt;url-pattern&gt;<br>
以上配置的路径，表示请求地址必须以.html结尾才会拦截到。<br>
<url-pattern class="jop-noMdConv"><em>.do<url-pattern class="jop-noMdConv"><br>
以上配置的路径，表示请求地址必须以.do结尾才会拦截到。<br>
<url-pattern class="jop-noMdConv"></em>.action<url-pattern class="jop-noMdConv"><br>
以上配置的路径，表示请求地址必须以.action结尾才会拦截到。</li>
</ul>
<p>Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！！<br>
<strong>哪怕你请求的资源并不存在，Filter它也会拦截。</strong></p>
<h3 id="threadlocal的使用">ThreadLocal的使用</h3>
<p>ThreadLocal的作用，它可以解决多线程的数据安全问题。<br>
ThreadLocal它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合）<br>
ThreadLocal的特点：<br>
1、ThreadLocal 可以为当前线程关联一个数据。（它可以像Map一样存取数据，key为当前线程）<br>
2、每一个ThreadLocal对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象实例。<br>
3、每个ThreadLocal对象实例定义的时候，一般都是static类型。<br>
4、ThreadLocal中保存的数据，在线程销毁后，会由JVM虚拟机自动释放。</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">public class ThreadLocalTest {

    public static Map&lt;String, Object&gt; data = new Hashtable&lt;&gt;();
    public static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;();
    public static Random random = new Random();

    public static class Task implements Runnable {
        @Override
        public void run() {
            // 在run()方法中随机生成一个变量，这个变量就是线程要关联的数据，然后以当前线程名为key保存到map中
            // 生成0-999的随机整数
            int i = random.nextInt(1000);
            // 获取当前线程名
            String name = Thread.currentThread().getName();
            System.out.println(&quot;线程[&quot; + name + &quot;]生成的随机数是&quot; + i);
            // data.put(name, i);
            threadLocal.set(i);
            // 做一些别的业务操作,把数据保存到ThreadLocal里， 只要是同一个线程，可以很方便的跨层取数据。比如从Service或Dao层里取数据。
            new OrderService().creatOrder();
            // 在run()方法快结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作
            // Object o = data.get(name);
            Object o = threadLocal.get();
            System.out.println(&quot;在线程[&quot; + name + &quot;]快结束时取出关联的数据是&quot; + o);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 3; i++) {
            new Thread(new Task()).start();
        }
    }
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// 在run()方法中随机生成一个变量，这个变量就是线程要关联的数据，然后以当前线程名为key保存到map中</span>
            <span class="hljs-comment">// 生成0-999的随机整数</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">1000</span>);
            <span class="hljs-comment">// 获取当前线程名</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();
            System.out.println(<span class="hljs-string">&quot;线程[&quot;</span> + name + <span class="hljs-string">&quot;]生成的随机数是&quot;</span> + i);
            <span class="hljs-comment">// data.put(name, i);</span>
            threadLocal.set(i);
            <span class="hljs-comment">// 做一些别的业务操作,把数据保存到ThreadLocal里， 只要是同一个线程，可以很方便的跨层取数据。比如从Service或Dao层里取数据。</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>().creatOrder();
            <span class="hljs-comment">// 在run()方法快结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作</span>
            <span class="hljs-comment">// Object o = data.get(name);</span>
            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> threadLocal.get();
            System.out.println(<span class="hljs-string">&quot;在线程[&quot;</span> + name + <span class="hljs-string">&quot;]快结束时取出关联的数据是&quot;</span> + o);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>()).start();
        }
    }
}</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">public class OrderService {
    public void creatOrder() {
        String name = Thread.currentThread().getName();
        // System.out.println(&quot;OrderService当前线程[&quot; + name + &quot;]保存的数据是：&quot; + ThreadLocalTest.data.get(name));
        System.out.println(&quot;OrderService当前线程[&quot; + name + &quot;]保存的数据是：&quot; + ThreadLocalTest.threadLocal.get());
        new OrderDAO().saveOrder();
    }
}</pre><pre class="hljs"><code><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> OrderService {
    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> creatOrder() {
        String <span class="hljs-type">name</span> = Thread.currentThread().getName();
        // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OrderService当前线程[&quot; + <span class="hljs-type">name</span> + &quot;]保存的数据是：&quot; + ThreadLocalTest.data.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>));
        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OrderService当前线程[&quot; + <span class="hljs-type">name</span> + &quot;]保存的数据是：&quot; + ThreadLocalTest.threadLocal.<span class="hljs-keyword">get</span>());
        <span class="hljs-built_in">new</span> OrderDAO().saveOrder();
    }
}</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">public class OrderDAO {
    public void saveOrder() {
        String name = Thread.currentThread().getName();
        // System.out.println(&quot;OrderDAO当前线程[&quot; + name + &quot;]保存的数据是：&quot; + ThreadLocalTest.data.get(name));
        System.out.println(&quot;OrderDAO当前线程[&quot; + name + &quot;]保存的数据是：&quot; + ThreadLocalTest.threadLocal.get());
    }
}</pre><pre class="hljs"><code><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> OrderDAO {
    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> saveOrder() {
        String <span class="hljs-type">name</span> = Thread.currentThread().getName();
        // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OrderDAO当前线程[&quot; + <span class="hljs-type">name</span> + &quot;]保存的数据是：&quot; + ThreadLocalTest.data.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>));
        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OrderDAO当前线程[&quot; + <span class="hljs-type">name</span> + &quot;]保存的数据是：&quot; + ThreadLocalTest.threadLocal.<span class="hljs-keyword">get</span>());
    }
}</code></pre></div>
<h4 id="回顾jdbc的数据库事务管理">回顾Jdbc的数据库事务管理</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">Connection conn = JdbcUtils.getConnection();
try {
    // 关闭事务自动提交
    conn.setAutoCommit(false); // 设置为手动管理事务	
    执行一系列的jdbc操作
    conn.commit(); // 手动提交事务
} catch (Exception e) {
    conn.rollback(); // 回滚事务	
} finally {
    try {
        JdbcUtils.close(conn); // 关闭连接																	   
    } catch (Exception e) {
        e.printStackTrace();												   
    }
}</pre><pre class="hljs"><code><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 关闭事务自动提交</span>
    conn.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为手动管理事务	</span>
    执行一系列的jdbc操作
    conn.commit(); <span class="hljs-comment">// 手动提交事务</span>
} <span class="hljs-keyword">catch</span> (Exception e) {
    conn.rollback(); <span class="hljs-comment">// 回滚事务	</span>
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">try</span> {
        JdbcUtils.close(conn); <span class="hljs-comment">// 关闭连接																	   </span>
    } <span class="hljs-keyword">catch</span> (Exception e) {
        e.printStackTrace();												   
    }
}</code></pre></div>
<p>要确保所有操作要么都成功。要吗都失败，就必须使用数据库的事务。<br>
<strong>要确保所有操作都在一个事务内，就必须要确保，所有操作都使用同一个Connection连接对象</strong></p>
<h4 id="如何确保所有操作都是用同一个connection连接对象">如何确保所有操作都是用同一个Connection连接对象？</h4>
<p><strong>我们可以使用ThreadLocal对象。来确保所有操作都使用同一个Connection对象</strong><br>
<strong>ThreadLocal要确保所有操作都使用同一个Connection连接对象。<br>
那么操作的前提条件是所有操作都必须在同一个线程中完成！</strong></p>
<h3 id="使用-filter-和-threadlocal-组合管理事务">使用 Filter 和 ThreadLocal 组合管理事务</h3>
<ul>
<li>将 Connection 放入 ThreadLocal 中<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">ThreadLocal&lt;Connection&gt; conns = new ThreadLocal&lt;Connection&gt;();
conns.set(conn); // 保存从数据库连接池中获取的连接对象</pre><pre class="hljs"><code>ThreadLocal&lt;Connection&gt; conns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Connection&gt;();
conns.set(conn); <span class="hljs-comment">// 保存从数据库连接池中获取的连接对象</span></code></pre></div>
</li>
<li>获取Connection<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">conns.get(); // 得到前面保存的Connection连接对象</pre><pre class="hljs"><code>conns.get(); <span class="hljs-comment">// 得到前面保存的Connection连接对象</span></code></pre></div>
</li>
<li>执行一系列的jdbc的操作<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">OrderService.createOrder();
// 同样的，这一系列操作都使用 conns.get() 来获取同一个Connection连接对象
OrderDao.saveOrder();
OrderItemDao.saveOrderItem();
BookDao.updateBook();</pre><pre class="hljs"><code>OrderService.createOrder();
<span class="hljs-comment">// 同样的，这一系列操作都使用 conns.get() 来获取同一个Connection连接对象</span>
OrderDao.saveOrder();
OrderItemDao.saveOrderItem();
BookDao.updateBook();</code></pre></div>
</li>
<li>手动提交事务<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 也是使用 conns.get() 来获取同一个Connection连接对象</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 也是使用 conns.get() 来获取同一个Connection连接对象</code></pre></div>
</li>
<li>回滚事务<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 也是使用 conns.get() 来获取同一个Connection连接对象</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 也是使用 conns.get() 来获取同一个Connection连接对象</code></pre></div>
</li>
<li>关闭连接<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">// 也是使用 conns.get() 来获取同一个Connection连接对象</pre><pre class="hljs"><code><span class="hljs-regexp">//</span> 也是使用 conns.get() 来获取同一个Connection连接对象</code></pre></div>
</li>
<li>具体的示例实现代码</li>
</ul>
<ol>
<li><strong>获取连接</strong></li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">// 声明一个ThreadLocal变量, 用来存储connection
private static ThreadLocal&lt;Connection&gt; conns = new ThreadLocal&lt;Connection&gt;();
// 获取数据库连接池中的连接
public static Connection getConection() {
    // 先尝试从ThreadLocal中获取
    Connection conn = conns.get();	
    // 如果ThreadLocal中没有，那么就从数据库连接池中获取一个新的Connection对象
    if (conn == null) {
        try {
            conn = dataSource.getConnection();
            // 把conn保存到ThreadLocal对象中，供后面的jdbc操作使用
            conns.set(conn);
            // 并设置当前conn对象为手动管理事务
            conn.setAutoCommit(false);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return conn;
}</pre><pre class="hljs"><code><span class="hljs-comment">// 声明一个ThreadLocal变量, 用来存储connection</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; conns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Connection&gt;();
<span class="hljs-comment">// 获取数据库连接池中的连接</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConection</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 先尝试从ThreadLocal中获取</span>
    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> conns.get();	
    <span class="hljs-comment">// 如果ThreadLocal中没有，那么就从数据库连接池中获取一个新的Connection对象</span>
    <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">try</span> {
            conn = dataSource.getConnection();
            <span class="hljs-comment">// 把conn保存到ThreadLocal对象中，供后面的jdbc操作使用</span>
            conns.set(conn);
            <span class="hljs-comment">// 并设置当前conn对象为手动管理事务</span>
            conn.setAutoCommit(<span class="hljs-literal">false</span>);
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        }
    }
    <span class="hljs-keyword">return</span> conn;
}</code></pre></div>
<ol start="2">
<li><strong>提交事务并关闭释放连接</strong></li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    public static void commitAndClose() {
        Connection conn = conns.get();
        if (conn != null) { // 如果不等于null， 说明之前使用过连接，操作过数据库
            try {
                conn.commit(); // 提交事务
            } catch (SQLException e) {
                e.printStackTrace();	
            } finally {
                try {
                    conn.close(); // 关闭连接，释放资源
                } catch (SQLException e) {
                    e.printStackTrace();	
                }
            }
        }
        // 一定要执行 threadLocal.remove()方法。
        // 否则threadLocal一直把持着这个conn，连接对象不能被GC释放掉，线程多了有可能内存溢出。
        // 另外，Tomcat服务器底层使用了线程池技术，线程池的某个线程会被反复使用，ThreadLocal的生命周期并不等于一次Request的生命周期，造成下一次用到这个线程的另一个Request获取threadLocal内的数据异常。
        conns.remove();
    }</pre><pre class="hljs"><code>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitAndClose</span>(<span class="hljs-params"></span>)</span> {
        Connection conn = conns.<span class="hljs-keyword">get</span>();
        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// 如果不等于null， 说明之前使用过连接，操作过数据库</span>
            <span class="hljs-keyword">try</span> {
                conn.commit(); <span class="hljs-comment">// 提交事务</span>
            } <span class="hljs-keyword">catch</span> (SQLException e) {
                e.printStackTrace();	
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">try</span> {
                    conn.close(); <span class="hljs-comment">// 关闭连接，释放资源</span>
                } <span class="hljs-keyword">catch</span> (SQLException e) {
                    e.printStackTrace();	
                }
            }
        }
        <span class="hljs-comment">// 一定要执行 threadLocal.remove()方法。</span>
        <span class="hljs-comment">// 否则threadLocal一直把持着这个conn，连接对象不能被GC释放掉，线程多了有可能内存溢出。</span>
        <span class="hljs-comment">// 另外，Tomcat服务器底层使用了线程池技术，线程池的某个线程会被反复使用，ThreadLocal的生命周期并不等于一次Request的生命周期，造成下一次用到这个线程的另一个Request获取threadLocal内的数据异常。</span>
        conns.<span class="hljs-keyword">remove</span>();
    }</code></pre></div>
<ol start="3">
<li><strong>回滚事务并关闭释放连接</strong></li>
</ol>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    public static void rollbackAndClose() {
        Connection conn = conns.get();
        if (conn != null) { // 如果不等于null， 说明之前使用过连接，操作过数据库
            try {
                conn.rollback(); // 回滚事务
            } catch (SQLException e) {
                e.printStackTrace();	
            } finally {
                try {
                    conn.close(); // 关闭连接，释放资源
                } catch (SQLException e) {
                    e.printStackTrace();	
                }
            }
        }
        // 一定要执行 threadLocal.remove()方法。
        // 否则threadLocal一直把持着这个conn，连接对象不能被GC释放掉，线程多了有可能内存溢出。
        // 另外，Tomcat服务器底层使用了线程池技术，线程池的某个线程会被反复使用，ThreadLocal的生命周期并不等于一次Request的生命周期，造成下一次用到这个线程的另一个Request获取threadLocal内的数据异常。
        conns.remove();
    }</pre><pre class="hljs"><code>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollbackAndClose</span>(<span class="hljs-params"></span>)</span> {
        Connection conn = conns.<span class="hljs-keyword">get</span>();
        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// 如果不等于null， 说明之前使用过连接，操作过数据库</span>
            <span class="hljs-keyword">try</span> {
                conn.rollback(); <span class="hljs-comment">// 回滚事务</span>
            } <span class="hljs-keyword">catch</span> (SQLException e) {
                e.printStackTrace();	
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">try</span> {
                    conn.close(); <span class="hljs-comment">// 关闭连接，释放资源</span>
                } <span class="hljs-keyword">catch</span> (SQLException e) {
                    e.printStackTrace();	
                }
            }
        }
        <span class="hljs-comment">// 一定要执行 threadLocal.remove()方法。</span>
        <span class="hljs-comment">// 否则threadLocal一直把持着这个conn，连接对象不能被GC释放掉，线程多了有可能内存溢出。</span>
        <span class="hljs-comment">// 另外，Tomcat服务器底层使用了线程池技术，线程池的某个线程会被反复使用，ThreadLocal的生命周期并不等于一次Request的生命周期，造成下一次用到这个线程的另一个Request获取threadLocal内的数据异常。</span>
        conns.<span class="hljs-keyword">remove</span>();
    }</code></pre></div>
<ol start="4">
<li>修改Dao、Servlet(Controller层代码)</li>
</ol>
<ul>
<li>Dao
<ul>
<li>Dao层不能关闭Connection，因为后续的操作还需要用到Connection，就得不到连接了。<br>
连接必须要在事务提交或者回滚的时候才能够关闭连接。</li>
<li>Dao层不能直接捕获异常，因为如果Dao捕获了异常且没有直接回滚，后续的操作不知道是否发生了		异常就不知道是否应该回滚。所以最好将Dao层的异常转换为运行时异常抛出给外层处理。</li>
</ul>
</li>
<li>Servlet
<ul>
<li>因为Dao层的异常转换为运行时异常抛出了，所以异常传给Service后即使不写throws也会自动向上一层继续抛出，所以可以在Servlet层(Controller)处理异常。</li>
</ul>
</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">    try {
        orderId = orderService.creatOrder(cart, userId);
        JdbcUtils.commitAndClose(); // 提交事务
    } catch (Exception e) {
        JdbcUtils.rollbackAndClose(); // 回滚事务
        e.printStackTrace();
    } </pre><pre class="hljs"><code>    <span class="hljs-keyword">try</span> {
        orderId = orderService.creat<span class="hljs-constructor">Order(<span class="hljs-params">cart</span>, <span class="hljs-params">userId</span>)</span>;
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcUtils</span>.</span></span>commit<span class="hljs-constructor">AndClose()</span>; <span class="hljs-comment">// 提交事务</span>
    } catch (Exception e) {
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcUtils</span>.</span></span>rollback<span class="hljs-constructor">AndClose()</span>; <span class="hljs-comment">// 回滚事务</span>
        e.print<span class="hljs-constructor">StackTrace()</span>;
    } </code></pre></div>
<h3 id="使用filter过滤器统一给所有的service方法都加上try-catch">使用Filter过滤器统一给所有的Service方法都加上try-catch</h3>
<p><img src="../_resources/bf5d04975f8a4dbab40719fff30d0fc1.png" alt="73910617f97988e01f590de74f8fd302.png"></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">public class TransactionFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain {
        try {
            filterChain.doFilter(servletRequest, servletResponse);
            JdbcUtils.commitAndClose();
        } catch (Exception e) {
            JdbcUtils.rollbackAndClose();
            e.printStackTrace();
        }
    }	
}</pre><pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">TransactionFilter</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Filter</span> {
    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain {
        <span class="hljs-keyword">try</span> {
            filterChain.doFilter(servletRequest, servletResponse);
            JdbcUtils.commitAndClose();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            JdbcUtils.rollbackAndClose();
            e.printStackTrace();
        }
    }	
}</code></pre></div>
<h3 id="json在java中的使用">JSON在Java中的使用</h3>
<ul>
<li>javaBean 和 json 的互转</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">// 创建Gson对象实例
Person person = new Person(1, &quot;男哥好帅&quot;);
// toJson方法可以把java对象转换成为json字符串
Gson gson = new Gson();
String personJsonString = gson.toJson(person);
// fromJson方法把JSON字符串转换会Java对象
Person person1 = gson.fromJson(personJsonString, Person.class)</pre><pre class="hljs"><code><span class="hljs-comment">// 创建Gson对象实例</span>
<span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男哥好帅&quot;</span>);
<span class="hljs-comment">// toJson方法可以把java对象转换成为json字符串</span>
<span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();
<span class="hljs-type">String</span> <span class="hljs-variable">personJsonString</span> <span class="hljs-operator">=</span> gson.toJson(person);
<span class="hljs-comment">// fromJson方法把JSON字符串转换会Java对象</span>
<span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> gson.fromJson(personJsonString, Person.class)</code></pre></div>
<ul>
<li>List 和 json 的互转</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">List&lt;Person&gt; personList = new ArrayList&lt;&gt;();
personList.add(new Person(1, &quot;华仔&quot;));
personList.add(new Person(2, &quot;星爷&quot;));
Gson gson = new Gson();
// toJson方法可以把java对象转换成为json字符串
String personListJsonString = gson.toJson(personList);
// fromJson方法把JSON字符串转换会Java对象
List&lt;Person&gt; personList1 = gson.fromJson(personListJsonString, new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType());</pre><pre class="hljs"><code>List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;华仔&quot;</span>));
personList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;星爷&quot;</span>));
<span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();
<span class="hljs-comment">// toJson方法可以把java对象转换成为json字符串</span>
<span class="hljs-type">String</span> <span class="hljs-variable">personListJsonString</span> <span class="hljs-operator">=</span> gson.toJson(personList);
<span class="hljs-comment">// fromJson方法把JSON字符串转换会Java对象</span>
List&lt;Person&gt; personList1 = gson.fromJson(personListJsonString, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;Person&gt;&gt;(){}.getType());</code></pre></div>
<ul>
<li>map 和 json 的互转</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">Map&lt;Integer, Person&gt; personMap = new HashMap&lt;&gt;();
personMap.put(1, new Person(1, &quot;男哥好帅&quot;));
personMap.put(2, new Person(2, &quot;猫爷好帅&quot;));
Gson gson = new Gson();
// 把 map 集合转换成 json 字符串
String personMapJsonString = gson.toString(personMap);
// fromJson方法把JSON字符串转换会Java对象
Map&lt;Integer, Person&gt; personMap1 = gson.fromJson(personMapJsonString, new TypeToken&lt;Map&lt;Integer, Person&gt;&gt;(){}.getType())</pre><pre class="hljs"><code>Map&lt;Integer, Person&gt; personMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
personMap.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;男哥好帅&quot;</span>));
personMap.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;猫爷好帅&quot;</span>));
<span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();
<span class="hljs-comment">// 把 map 集合转换成 json 字符串</span>
<span class="hljs-type">String</span> <span class="hljs-variable">personMapJsonString</span> <span class="hljs-operator">=</span> gson.toString(personMap);
<span class="hljs-comment">// fromJson方法把JSON字符串转换会Java对象</span>
Map&lt;Integer, Person&gt; personMap1 = gson.fromJson(personMapJsonString, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;Map&lt;Integer, Person&gt;&gt;(){}.getType())</code></pre></div>
<h3 id="i18n国际化">i18n国际化</h3>
<h4 id="什么是i18n国际化">什么是i18n国际化</h4>
<p><img src="../_resources/3657ef41c93944c8a91793acf3125c6b.png" alt="228c71d02c04232282d47004300c59b2.png"></p>
<h4 id="国际化三要素">国际化三要素</h4>
<ul>
<li>Locale对象表示不同时区，位置，语言</li>
<li>Properties属性配置文件，命名：i18n_zh_CN.properties，存储了相同key的不同语言的键值对</li>
<li>ResourceBundle对象，getBundle()方法，根据指定的baseName和Locale读取相应的配置文件，得到该Local对应的文字信息。ResourceBundle.getString(key)得到对应国家对应key的文字<br>
<img src="../_resources/76d261fd836646deb653c495383177ae.png" alt="ce25a369b4376772b551887862acb405.png"></li>
</ul>
<h4 id="国际化基础示例">国际化基础示例</h4>
<p><img src="../_resources/82e72d1e71b34ebcb86082ae6478a931.png" alt="9832fc74aa7552e869151c908719b30a.png"></p>
<h4 id="从请求头中获取locale对象">从请求头中获取Locale对象</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="java" data-joplin-source-open="```java&#10;" data-joplin-source-close="&#10;```">// 根据请求头中的Accept-Language字段来获取
Locale locale = request.getLocale();</pre><pre class="hljs"><code><span class="hljs-comment">// 根据请求头中的Accept-Language字段来获取</span>
<span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> request.getLocale();</code></pre></div>
<h3 id="ajax请求">AJAX请求</h3>
<h4 id="什么是ajax请求">什么是AJAX请求</h4>
<p>AJAX 即 “Asynchronous Javascript And XML”（异步JavaScript和XML），是一种创建交互式网页应用的网页开发技术。<br>
<strong>ajax是一种浏览器通过js异步发起请求。局部更新页面的技术。</strong></p>
<h4 id="原生javascipt的ajax请求示例">原生JavaScipt的AJAX请求示例</h4>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="javascipt" data-joplin-source-open="```javascipt&#10;" data-joplin-source-close="&#10;```">// 在这里使用javaScript语言发起Ajax请求
function ajaxRequest() {
    // 1. 首先创建XMLHttpRequest
    var xmlhttprequest = new XMLHttpRequest();
    // 2. 调用open方法设置请求类型，地址，是否为异步
    xmlhttprequest.open(&quot;GET&quot;, &quot;http://localhost:8080/JQuery/ajaxServlet?action=javaScriptAjax&quot;, true);
    // 3. 在send方法前绑定onreadystatechange事件，处理请求完成后的操作	
    xmlhttprequest.onreadystatechange = function() {
        if (xmlhttprequest.readyState == 4) &amp;&amp; xmlhttprequest.status == 200) {
            // 这行代码旨在测试异步和同步的区别，同步按代码顺序执行，异步不是。
            alert(&quot;收到服务器返回的数据：&quot; + xmlhttprequest.responseText)；
            var jsonObj = JSON.parse(xmlhttprequest.responseText);
            document.getElementByID(&quot;div01&quot;).innerHTML = &quot;编号：&quot; + jsonObj.id + &quot;姓名：&quot; + jsonObj.name;
        }
    }
    // 4. 调用send方法发送请求
    xmlhttprequest.send();
    // 5. 测试异步和同步的区别
    alert(&quot;我是最后一行代码&quot;)；
}</pre><pre class="hljs"><code><span class="hljs-comment">// 在这里使用javaScript语言发起Ajax请求</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajaxRequest</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 1. 首先创建XMLHttpRequest</span>
    <span class="hljs-keyword">var</span> xmlhttprequest = <span class="hljs-keyword">new</span> XMLHttpRequest();
    <span class="hljs-comment">// 2. 调用open方法设置请求类型，地址，是否为异步</span>
    xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080/JQuery/ajaxServlet?action=javaScriptAjax&quot;</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">// 3. 在send方法前绑定onreadystatechange事件，处理请求完成后的操作	</span>
    xmlhttprequest.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (xmlhttprequest.readyState == <span class="hljs-number">4</span>) &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>) {
            <span class="hljs-comment">// 这行代码旨在测试异步和同步的区别，同步按代码顺序执行，异步不是。</span>
            alert(<span class="hljs-string">&quot;收到服务器返回的数据：&quot;</span> + xmlhttprequest.responseText)；
            <span class="hljs-keyword">var</span> jsonObj = <span class="hljs-built_in">JSON</span>.parse(xmlhttprequest.responseText);
            <span class="hljs-built_in">document</span>.getElementByID(<span class="hljs-string">&quot;div01&quot;</span>).innerHTML = <span class="hljs-string">&quot;编号：&quot;</span> + jsonObj.id + <span class="hljs-string">&quot;姓名：&quot;</span> + jsonObj.name;
        }
    }
    <span class="hljs-comment">// 4. 调用send方法发送请求</span>
    xmlhttprequest.send();
    <span class="hljs-comment">// 5. 测试异步和同步的区别</span>
    alert(<span class="hljs-string">&quot;我是最后一行代码&quot;</span>)；
}</code></pre></div>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"></pre><pre class="hljs"><code></code></pre></div>
<p>XMLHttpRequest对象的<strong>responseText</strong>对象来接收服务器端返回的字符串格式的数据<br>
XMLhttpRequest对象有<strong>readyState</strong>和<strong>status</strong>属性，<br>
当 readyState = 4 并且 status = 200 时，表示响应已就绪。<br>
<strong>onreadystatechange</strong>事件表示，每当readyState属性值改变时，就会调用该函数。<br>
<img src="../_resources/4888250c81334bf0b3a59f44d9179f18.png" alt="7bcd4d0bd8177d6b9a9420b8a53efd04.png"><br>
<img src="../_resources/fdffbe2292294036b955bae440d70b66.png" alt="eba7490da75f66dbe86f2a5eb41c11c0.png"></p>
<h4 id="怎么理解ajax的局部更新">怎么理解AJAX的局部更新？</h4>
<p>Ajax请求的局部更新，浏览器地址栏不会变化<br>
局部更新不会舍弃原来页面的内容</p>
<h4 id="怎么理解ajax的异步请求">怎么理解AJAX的异步请求？</h4>
<h5 id="什么叫同步">什么叫同步？</h5>
<p>比如说你跟你一个朋友一起出去玩，结果中间他要去大号，他说你等我，等我回来咱们一起走。</p>
<h5 id="什么叫异步">什么叫异步？</h5>
<p>异步就你朋友去大号，然后说你不用等我，你先去排队或是吃点零食自个玩去，等我拉完我追上你。</p>
<h5 id="ajax异步请求">AJAX异步请求</h5>
<p>异步请求就是页面不会等服务器把数据返回来之后才会继续执行，而是页面请求一发送出去页面不管请求啥时候回来就立刻继续往下执行，然后需要页面返回数据的代码，什么时候返回什么时候执行。这就是异步。</p>
<h5 id="为什么要有异步请求">为什么要有异步请求？</h5>
<p>因为异步带来了良好的用户体验，而同步的请求会让你操作的发狂，点一下页面假死等半天，再点一下页面又半天，直到最后请求回来了，页面才能继续执行和渲染。</p>
<h4 id="jquery中的ajax请求">jQuery中的AJAX请求</h4>
<h5 id="ajax方法">$.ajax方法</h5>
<ul>
<li>url 表示请求的地址</li>
<li>type 表示请求的类型GET或POST请求</li>
<li>data 表示发送给服务器的数据<br>
格式有两种：<br>
1. name=value&amp;name=value<br>
2. {key:value, key:value}</li>
<li>success 请求成功，响应的回调函数</li>
<li>dataType 预期响应的数据类型<br>
常用的数据类型有：<br>
1. text 表示纯文本<br>
2. xml 表示 xml 数据<br>
3. json 表示 json 对象</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="javascipt" data-joplin-source-open="```javascipt&#10;" data-joplin-source-close="&#10;```">$(function(){
    // ajax 请求
    $(&quot;#ajaxBtn&quot;).click(function(){
        $.ajax({
            url:&quot;http:localhost:8080/JQuery/ajaxServlet&quot;,
            data:{action:&quot;jQueryAjax&quot;},
            // data:&quot;action=jQueryAjax&quot;,
            type:&quot;GET&quot;,
            // 必须给一个形参来接收回调数据
            success:function(data) {
                alert(&quot;服务器返回的数据是：&quot; + data);
            },
            // 如果指定为text，那么接收到的就是普通文本，需要自己用JSON.parse(data)方法转换为json对象
            dataType:&quot;text&quot;
            // 如果指定为json，那么接收到的数据会自动转换为json对象装入data中
            dataType:&quot;json&quot;
        })
    })
})</pre><pre class="hljs"><code>$(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">// ajax 请求</span>
    $(<span class="hljs-string">&quot;#ajaxBtn&quot;</span>).click(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        $.ajax({
            <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http:localhost:8080/JQuery/ajaxServlet&quot;</span>,
            <span class="hljs-attr">data</span>:{<span class="hljs-attr">action</span>:<span class="hljs-string">&quot;jQueryAjax&quot;</span>},
            <span class="hljs-comment">// data:&quot;action=jQueryAjax&quot;,</span>
            type:<span class="hljs-string">&quot;GET&quot;</span>,
            <span class="hljs-comment">// 必须给一个形参来接收回调数据</span>
            success:<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) {
                alert(<span class="hljs-string">&quot;服务器返回的数据是：&quot;</span> + data);
            },
            <span class="hljs-comment">// 如果指定为text，那么接收到的就是普通文本，需要自己用JSON.parse(data)方法转换为json对象</span>
            dataType:<span class="hljs-string">&quot;text&quot;</span>
            <span class="hljs-comment">// 如果指定为json，那么接收到的数据会自动转换为json对象装入data中</span>
            dataType:<span class="hljs-string">&quot;json&quot;</span>
        })
    })
})</code></pre></div>
</div></div>
					</body>
				</html>
			