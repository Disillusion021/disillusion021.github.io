0. 类什么时候被加载？
	创建对象实例时(new 对象时)
	创建子类对象实例时，父类也会被加载，而且父类先被加载，子类后被加载
	使用类的静态成员时(静态变量，静态方法)

1. 代码块
	普通代码块相当于另一种形式的构造器
	如果多个构造器中有重复语句，可以抽离到初始化代码块中
	代码块的优先级高于构造器
	
	static代码块会在类加载时执行，且只会执行一次
	普通代码块在创建对象时执行，每创建一次执行一次

2. 创建一个对象时，初始化的调用顺序？
	1. 调用静态代码块和静态属性初始化(优先级相同，按定义顺序执行)
	2. 调用普通代码块和普通属性初始化(优先级相同，按定义顺序执行)
	3. 调用构造方法

3. 创建一个对象，过程细化
	1. 父类的静态代码块和静态属性
	2. 子类的静态代码块和静态属性
	3. 父类的普通代码块和普通属性
	4. 父类的构造方法
	5. 子类的普通代码块和普通属性
	6. 子类的构造方法

可以理解为
	 构造器{
		super();
		普通代码块和普通属性初始化(按定义顺序执行);
		构造器语句；
	}

内部类

1. 定义在外部类局部位置上（比如方法内）
	1. 局部内部类（有类名）
	2. 匿名内部类（没有类名）
2. 定义在外部类成员位置上
	1. 成员内部类（没用static修饰）
	2. 静态内部类（使用static修饰）


局部内部类：定义在外部类的局部位置，通常在方法中，***相当于一个局部变量***
	1. 局部内部类可以访问外部类中所有成员，包含私有的
	2. 局部内部类相当于一个局部变量，不能被任何访问修饰符修饰，只能被final修饰(因为局部变量也可以被final修饰)
	3. 局部内部类作用域为定义它的方法或代码块中
	4. 局部内部类可以直接访问外部类的成员，外部类可以直接new内部类来使用内部类,其他类不能访问局部内部类
	5. 如果外部类和内部类成员重名时，遵循就近原则，先访问局部内部类成员，不过可以通过 外部类.this.成员名 来访问外部类成员。	外部类.this 本质就是当前调用此外部类方法的外部类对象

匿名内部类：本质是一个隐藏了名字的内部类，并且创建了一个对象。***匿名内部类继承了某个接口或某个类***
	基本语法：
		new 类 or 接口（参数列表）{
			类体
		};

		0. 基于接口/类的匿名内部类
		1. 需求：想使用Animal接口/类，并创建对象
		2. 传统方式，是写一个类，实现该接口/或继承该类，并创建对象
		3. 现在的需求是：Cat类只是使用一次，后面不再使用，可不可以不单独为了这一次的使用创建一个Cat类
		4. 可以使用匿名内部类来简化开发
		5. Cat的编译类型是? 编译类型就是等号左边的Animal
		6. Cat的运行类型是? ***运行类型就是这个匿名内部类***
			匿名内部类的底层：
			class 匿名内部类名 implements/extends Animal {
				@Override
				方法重写
			}
			其实底层里匿名内部类的确创建了一个类并实现了接口/或继承了类，而且默认赋予了一个类名，这个类名就等于外部类名+$1/2/3...
		7. jdk底层在创建匿名内部类，立即就创建了一个匿名内部类的实例
		8. 匿名内部类只能使用一次
		9. 匿名内部类的应用场景：匿名内部类可以直接作为实参传递给方法形参，从而实现一种简洁灵活的多态

成员内部类：
定义在类里的成员位置，不加static修饰的类叫做成员内部类

静态内部类：
定义在类的成员位置，使用static修饰的类叫做静态内部类
静态内部类只能访问外部类所有静态成员。
外部类通过创建对象访问静态内部类。
外部其他类 通过 new 外部类名.内部类构造方法得到静态内部类的对象。


































public int hashcode()，返回对象的哈希码，哈希码是将对象地址(貌似并不是真正的内部地址)转换为的一个整数。
	1. 如果指向同一个对象，那么哈希码一定相等。
	2. 如果指向两个不同的对象，那么哈希码一般不相等，不过也可以相等。
	3. 实际上，Object类定义的hashcode()方法确实会根据不同的对象返回不同的哈希码。
	4. hashcode()方法规定了，若两个对象equals相等，其hashcode()方法应该重写以保证这两个对象的哈希码也一定相等。